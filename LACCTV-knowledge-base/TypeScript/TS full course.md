![Базовый курс по TypeScript](https://youtu.be/ZvZ7gvcmPmI?si=Ke8nLyoPe_SvVLk3)


### Что такое TypeScript?

- **Надмножество JavaScript**: TypeScript – это мощное надмножество JavaScript со статической типизацией, которое помогает писать более безопасный и поддерживаемый код.
- **JavaScript с синтаксисом для типов**: По сути, это JavaScript с добавлением синтаксиса для определения типов.
- **Проверка типов**: TypeScript добавляет проверку типов к JavaScript, что позволяет обнаруживать ошибки, связанные с типами, на этапе компиляции, еще до выполнения кода.
    - Это помогает выявлять и устранять проблемы на ранних стадиях разработки.
    - Например, в JavaScript `2 + 2` может вернуть `22`, но с TypeScript такие проблемы исчезают.
- **Типизация**:
    - **Статическая типизация**: TypeScript использует статическую типизацию, что отличает его от других языков. В статически типизированных языках (например, C++, C#, Java) тип переменной объявляется во время компиляции или кодирования и не может быть изменен. Это делает код безопаснее и менее подвержен ошибкам.
    - **Динамическая типизация**: В динамически типизированных языках (например, JavaScript, Python, Ruby) типы переменных определяются во время выполнения и могут изменяться в процессе выполнения, что может привести к неожиданному поведению или сбоям. TypeScript решает эту проблему.

### Зачем изучать TypeScript?

- **Высокий спрос в отрасли**: Это ценный навык на рынке труда.
- **Упрощает JavaScript**: JavaScript может быть сложным, но TypeScript упрощает его и делает более надежным.
- **Эффективность**: TypeScript сокращает необходимость в модульном тестировании, экономя время.
- **Предотвращение ошибок и быстрая обратная связь**: Он обнаруживает ошибки до запуска и обеспечивает мгновенную обратную связь для более быстрой и надежной разработки.
- **Бесшовная интеграция**: TypeScript легко интегрируется с JavaScript, делая адаптацию безболезненной.
- **Расширение фреймворков**: TypeScript улучшает популярные фреймворки, такие как React, Vue и Angular, с помощью расширенных функций, например, интерфейсов.
- **Более надежное и поддерживаемое приложение**: Помогает создавать более надежные и поддерживаемые приложения, сокращая время разработки.

### Как работает TypeScript?

- **Транспиляция**: Компилятор TypeScript **компилирует код TS в код JavaScript**. Этот процесс называется транспиляцией.
- **Использование**: TypeScript можно использовать во многих областях, от фронтенда до бэкенда.

### Настройка и создание первого приложения

Для работы с курсом потребуются базовые знания JavaScript и следующие шаги по установке:

1. **Установите Git**: Загрузите Git с официального сайта.
2. **Установите Visual Studio Code (VS Code)**: Загрузите VS Code с официального сайта.
3. **Установите NodeJS**: Загрузите NodeJS с официального сайта, выбрав версию LTS (Long Term Support) для стабильности.
    - **Проверьте установку NodeJS**: Откройте командную строку (например, Git Bash) и выполните команду `node -v`.
4. **Установите TypeScript глобально**: Используйте менеджер пакетов NodeJS (npm).
    - Выполните команду: `npm install -g TypeScript`.
    - **Проверьте установку TypeScript**: Выполните `tsc -v`.

**Создание и запуск первого приложения:**

1. **Создайте папку**: Например, `TypeScript` на рабочем столе.
2. **Создайте файл `index.ts`**: Внутри папки TypeScript создайте файл `index.ts` и откройте его в VS Code.
3. **Напишите код**: Например, `console.log(Math.floor);`.
    - VS Code сразу выделит `Math.floor` как проблемный, указывая на "ожидается один аргумент, получено ноль" при наведении.
    - Исправьте, добавив аргумент, например: `console.log(Math.floor(11.3));`.
4. **Компилируйте код TypeScript в JavaScript**:
    - Откройте Git Bash и перейдите в каталог с вашим файлом TypeScript.
    - Используйте команду `tsc`, чтобы скомпилировать `index.ts` в `index.js`.
5. **Запустите файл JavaScript**:
    - После компиляции выполните команду `node index.js`, чтобы запустить сгенерированный JavaScript-файл.

**Конфигурация проекта с `tsconfig.json`:**

6. **Структурируйте проект**: Создайте папку `src` и переместите `index.ts` в нее.
7. **Сгенерируйте `tsconfig.json`**: Выполните команду `tsc --init` в корневой директории проекта. Это создаст файл `tsconfig.json` с настройками по умолчанию.
8. **Настройте `tsconfig.json`**:
    - Откройте `tsconfig.json` в VS Code.
    - Настройте `rootDir` (корневой каталог для исходных файлов TypeScript) на `src`.
    - Настройте `outDir` (выходной каталог для скомпилированных файлов JavaScript) на `dist`.
    - Сохраните изменения.
9. **Компилируйте код TypeScript**: Запустите `tsc`. TypeScript будет использовать настройки из `tsconfig.json`.
10. **Запустите скомпилированный код**: Используйте `node dist/index.js`.

### Ключевые особенности TypeScript (Типы и аннотации)

**Типы в TypeScript:** Помимо встроенных типов JavaScript (числа, строки, булевы значения, null, undefined, объекты), TypeScript расширяет этот список, вводя новые типы, такие как `any`, `unknown`, `never`, `enum` и `tuple`, для создания более универсальной и надежной системы типов.

**Аннотации типов:** Аннотации типов используются для явного указания типа переменной, функции или любого другого объекта. Они помогают компилятору TypeScript понять и применить предполагаемое использование в вашей программе. Обычно добавляются с помощью двоеточия, за которым следует тип.

- **С переменными**: Вы можете явно аннотировать типы переменных. Например: `let myNumber: number;` или `let myString: string = "hello";`.
    - Это повышает надежность, поддерживаемость и уменьшает количество ошибок.
- **Динамическое определение типов (вывод типов)**: Если вы не используете аннотации типов, TypeScript все равно может динамически определить тип на основе вашего объявления. Например, `let greeting = "Hello, world!";` автоматически выведет тип `string`.
    - Однако **не рекомендуется полагаться только на вывод типов**, так как это может привести к неожиданным проблемам. Явное определение типов через аннотации является лучшей практикой.

**Специальные типы:**

- **`any` (любой):**
    - Специальный тип, который может представлять любое значение.
    - При присвоении переменной типа `any` компилятор TypeScript отключает проверку типов для этой переменной.
    - Пример: `let myVariable: any;`.
    - **Не рекомендуется использовать `any` везде, где это возможно**, так как это снижает типобезопасность и надежность кода.
- **`void` (пустота):**
    - Используется для указания **отсутствия значения**.
    - Представляет функцию, которая не возвращает никакого значения или возвращает `undefined`. Часто используется для аннотирования функций, которые выполняют действия или побочные эффекты, но не производят значимого результата, который нужно присвоить или захватить.
- **`never` (никогда):**
    - Используется для представления значений, которые **никогда не возникают**.
    - Обычно ассоциируется с функциями, которые никогда не возвращаются (например, бросают исключения, выполняются в бесконечных циклах или имеют недостижимый код).

**Аннотации типов с объектами:** Позволяют указывать типы свойств, которые должен иметь объект. Пример:

```
let personExample2: {
  name: string;
  age: number;
  jobTitle?: string; // Опциональное свойство
  address: {
    street: string;
    city: string;
  };
} = {
  name: "John Doe",
  age: 30,
  address: {
    street: "123 Main St",
    city: "New York",
  },
};
```

Можно объявлять объект и его свойства с аннотациями типов, а затем инициализировать его значениями.

**Аннотации типов с функциями:** Используются для явного указания типов данных для параметров функции и возвращаемых значений. Пример:

```
function calculateRectangleArea(length: number, width: number): number {
  return length * width;
}
```

- Параметры и возвращаемое значение аннотируются с помощью двоеточия.
- **Опциональные параметры:** Могут быть пропущены при вызове функции. Обозначаются вопросительным знаком после имени параметра (например, `age?: number`).
- **Параметры по умолчанию:** Автоматически принимают значение по умолчанию, если аргумент не предоставлен. Обозначаются оператором присваивания (например, `age: number = 30`).
- **Параметры "rest":** Позволяют функции принимать неопределенное количество аргументов в виде массива. Обозначаются оператором spread (`...`) перед именем параметра (например, `...nums: number[]`). Эти аргументы собираются в массив внутри функции.

**Объединяющие типы (Union Types):** Позволяют переменной содержать значения нескольких типов. Обозначаются символом `|` между типами. Пример: `let myVar: string | number;`. Переменная `myVar` может быть строкой или числом.

**Литеральные типы (Literal Types):** Позволяют указывать **точное значение**, которое разрешено для переменной или параметра функции, вместо общего типа. Пример: `type Direction = "left" | "right" | "up" | "down";`. Переменная `direction` может принимать только одно из этих четырех строковых значений. Это повышает типобезопасность, перехватывая ошибки на этапе компиляции.

**Обнуляемые типы (Nullable Types):** Позволяют переменной или параметру иметь определенный тип данных (например, `string` или `number`) или специальное значение `null`. Создаются путем добавления `| null` к существующему типу данных. Пример: `let username: string | null;`. Помогают улучшить безопасность кода, явно указывая возможность отсутствия или неопределенных данных.

**Псевдонимы типов (Type Aliases):** Позволяют создавать **пользовательские имена для типов**. Это способ определить свой собственный тип, который может состоять из существующих типов (числа, строки, объекты) или других пользовательских типов. Пример: `type MyString = string;` или `type MyStringOrNumber = string | number;`. Повышают читаемость, поддерживаемость и повторное использование сложных определений типов. Могут использоваться с объектами для определения сложных структур.

**Пересекающиеся типы (Intersection Types):** Позволяют **объединять несколько типов** в один, создавая новый тип, который имеет все свойства и функциональность отдельных типов. Обозначаются оператором `&`. Пример: `type CombinedType = FirstType & SecondType;`. `CombinedType` будет включать все свойства из `FirstType` и `SecondType`.

**Аннотации типов с массивами:** Позволяют указывать ожидаемый тип данных элементов массива. Пример: `let fruits: string[] = ["apple", "banana"];`.

- **Многомерные массивы**: `let arrayOne: number[][] = [,];`.
- Массивы могут содержать элементы разных типов, используя объединяющие типы: `let arrayThree: (string | number)[] = ["hello", 123];`.

**Кортежи (Tuples):** Тип данных, похожий на массив, но имеющий **фиксированное количество элементов**, и вы можете указать типы каждого элемента на конкретной позиции. Пример: `let article: [number, string, boolean] = [1, "TypeScript", true];`. Кортежи имеют фиксированный размер и не могут иметь дополнительные элементы.

**Перечисления (Enums):** Позволяют определять **набор именованных постоянных значений**, представляющих дискретные опции или категории. По умолчанию значения начинаются с нуля. Пример:

```
enum Days {
  Sunday,
  Monday,
  Tuesday,
  Wednesday,
}
let today: Days = Days.Wednesday; // today будет 3
```

Делают код более читаемым, предоставляя удобочитаемые имена для конкретных значений.

**Интерфейсы (Interfaces):** Способ определения **конструкции или шаблона** для формы и структуры объекта. Интерфейс определяет набор правил, которым должен следовать объект, чтобы считаться действительным.

- **Определение формы**: Интерфейсы определяют структуру объекта, включая имена свойств, их типы и статус (опциональные/обязательные).
- **Контракт**: Объекты или классы, придерживающиеся интерфейса, должны реализовывать определенную структуру и методы.
- **Проверка типов**: TypeScript проверяет, соответствует ли объект требованиям интерфейса, перехватывая ошибки типов на ранней стадии.
- **Четкость кода**: Интерфейсы документируют ожидаемые свойства объекта и улучшают читаемость кода.
- **Пример базового определения:**
    
    ```
    interface PersonExample1 {
      name: string;
      age: number;
    }
    let alice: PersonExample1 = { name: "Alice", age: 30 };
    ```
    
- **Методы и параметры интерфейса:** Интерфейс может определять не только структуру объекта, но и сигнатуру функций или методов, которые должен иметь объект, придерживающийся интерфейса.
    
    ```
    interface PersonExample2 {
      name: string;
      age: number;
      greet(message: string): void;
    }
    ```
    
- **Повторное открытие интерфейса (Interface Reopening):**
    - Ценная техника для наращивания и расширения интерфейсов по мере роста проекта.
    - Позволяет создавать универсальные, гибкие и согласованные структуры объектов.
    - Пример: вы можете определить интерфейс `Sitting` сначала с `theme` и `font`, а затем "переоткрыть" его, чтобы добавить `sidebar` для страницы статей, и снова для `external` для страницы контактов. Все эти свойства будут объединены.
    - Позволяет **модульную разработку**, **прогрессивное улучшение** и **четкое разделение задач**.
- **Встроенные интерфейсы:**
    - Предоставляются языком TypeScript или базовой средой выполнения JavaScript.
    - Определяют форму и поведение объектов для конкретных случаев использования.
    - Примеры: `HTMLElement`, `HTMLDivElement`, `HTMLAnchorElement`, `HTMLImageElement`.
    - **HTMLImageElement**: Встроенный интерфейс, представляющий элемент HTML-изображения, расширяющий `HTMLElement`. Предоставляет свойства (например, `alt`, `height`, `src`, `width`) и методы (например, `complete`, `decode`, `naturalHeight`, `naturalWidth`).
- **Сравнение с псевдонимами типов (Type Aliases):**
    - **Синтаксис объявления**: `interface` для интерфейсов, `type` для псевдонимов типов.
    - **Расширение и реализация**: Интерфейсы могут быть расширены (`extends`) другими интерфейсами и реализованы (`implements`) классами. Псевдонимы типов не могут быть расширены или реализованы напрямую, но аналогичный результат достигается с помощью пересекающихся типов.
    - **Совместимость (Declaration Merging)**: Интерфейсы поддерживают слияние объявлений (TypeScript объединяет несколько интерфейсов с одинаковым именем в один). Псевдонимы типов не поддерживают слияние объявлений.
    - **Расширяемость**: Интерфейсы лучше подходят для определения формы объекта, особенно когда классы должны придерживаться этой формы. Псевдонимы типов полезны для создания пользовательских типов, которые могут быть объединены с помощью объединяющих или пересекающихся типов.
    - **Читаемость и стиль**: Интерфейсы предпочтительны для определения форм объектов (особенно для публичных API), хорошо работают с автозаполнением. Псевдонимы типов полезны для определения объединяющих, пересекающихся и более сложных типов.
    - Выбор между ними зависит от конкретного случая использования и стиля кодирования.

**Классы (Classes):** Шаблон для создания объектов с общими свойствами и методами.

- **Аннотации типов в классах:** Используются для указания типов свойств, методов и параметров конструктора внутри класса. Помогают отлавливать ошибки на этапе компиляции.
    - Пример:
        
        ```
        class Product {
          id: number;
          name: string;
          price: number;
          constructor(id: number, name: string, price: number) { /* ... */ }
          getProductInfo(): string { /* ... */ }
        }
        ```
        
- **Модификаторы доступа (Access Modifiers):** Ключевые слова, используемые для контроля видимости и доступности членов класса (свойств и методов) извне класса.
    - **`public` (публичный)**: Доступен отовсюду (по умолчанию).
    - **`private` (приватный)**: Доступен только изнутри класса, в котором он определен.
    - **`protected` (защищенный)**: Доступен изнутри класса, в котором он определен, и из подклассов (производных классов).
    - Помогают инкапсулировать внутренние детали класса и контролировать доступ.
- **Аксессоры (Accessors) / Геттеры и Сеттеры:** Способ контролировать доступ к свойствам класса. Определяются с помощью ключевых слов `get` и `set`. Позволяют добавлять дополнительную логику при получении или установке значений.
- **Статические члены класса (Static Members):** Свойства или методы, которые принадлежат самому классу, а не его экземплярам. Доступны без создания экземпляра класса. Определяются с помощью ключевого слова `static`. Используются, например, для управления уникальными идентификаторами.
- **Реализация интерфейса классом (Class implements Interface):** Класс может реализовать интерфейс, используя ключевое слово `implements`. Это гарантирует, что класс предоставляет свойства и методы, требуемые этим интерфейсом, обеспечивая согласованную структуру.
- **Абстрактные классы и члены (Abstract Classes and Members):**
    - **Абстрактные классы**: Используются как **шаблон для других классов**. Не могут быть инстанцированы самостоятельно, но могут быть подклассированы. Могут содержать абстрактные методы.
    - **Абстрактные методы**: Объявляются, но не реализуются в самом абстрактном классе. Подклассы обязаны предоставить реализации для этих абстрактных методов.
- **Полиморфизм и переопределение методов (Polymorphism and Method Overriding):**
    - **Полиморфизм**: Позволяет объектам разных классов обрабатываться как объекты общего суперкласса.
    - **Переопределение методов**: Подклассы предоставляют специфическую реализацию метода, который уже определен в родительском классе, позволяя подклассу настраивать поведение этого метода. Это позволяет создавать различные типы сущностей, придерживаясь общего интерфейса, предоставляемого абстрактным классом.
- **Различия между классом и интерфейсом:** Класс предназначен для создания объектов, в то время как интерфейс предназначен для определения формы объекта.

**Дженерики (Generics):** Функция, которая позволяет писать **многократно используемый код** путем передачи типа в качестве параметра другому типу (будь то класс, интерфейс или функция). Это позволяет гибко работать с различными типами без использования типа `any`.

- **Преимущества:**
    - **Повторное использование кода**: Один и тот же код может быть использован с разными типами без его переписывания.
    - **Повышенная безопасность**: Дженерики помогают обнаруживать потенциальные ошибки на этапе компиляции, а не во время выполнения.
    - **Работа с несколькими типами**: Позволяют работать со множеством типов, не указывая конкретный тип.
- **Использование:**
    - **Дженерик-функции:**
        
        ```
        function returnType<T>(value: T): T {
          return value;
        }
        let num = returnType<number>(10);
        let str = returnType<string>("hello");
        ```
        
    - **Дженерики с несколькими типами:** Могут обрабатывать несколько типов, используя объединяющие или пересекающиеся типы.
        
        ```
        function multipleType<T, S>(value1: T, value2: S): string {
          return `${value1} and ${value2}`;
        }
        ```
        
    - **Дженерик-классы:** Позволяют создавать гибкие и многократно используемые структуры классов, которые могут работать с различными типами данных.
        
        ```
        class User<T = string> { // T по умолчанию string
          value: T;
          constructor(initialValue: T) {
            this.value = initialValue;
          }
          show(message: T) {
            console.log(message, this.value);
          }
        }
        let user1 = new User<number>(123);
        let user2 = new User("hello");
        ```
        
    - **Дженерики в интерфейсах:** Позволяют создавать многократно используемые и типобезопасные структуры данных, которые могут работать с различными типами.
        
        ```
        interface Book { title: string; author: string; }
        interface Game { name: string; genre: string; }
        interface Collection<T> {
          data: T[];
          add(item: T): void;
        }
        class MyCollection<T> implements Collection<T> { /* ... */ }
        let bookCollection: Collection<Book> = new MyCollection<Book>();
        ```
        

**Утверждения типа (Type Assertions):** Способ явно информировать компилятор TypeScript об ожидаемом типе значения, даже когда компилятор не может его определить. Это как сказать TypeScript: "Доверься мне, я знаю, что это за тип". Пример: `let data: any = "some string"; let strLength: number = (data as string).length;`.

### Отладка приложений TypeScript в VS Code

Отладка — бесценный навык для устранения проблем.

11. **Включите Source Map:**
    - Откройте файл `tsconfig.json`.
    - В разделе `compilerOptions` установите `sourceMap` в `true`.
    - Source Map — это файл, который помогает сопоставить каждую строку кода TypeScript с соответствующим кодом JavaScript, что важно для отладчиков.
12. **Перекомпилируйте код:**
    - После включения Source Map перекомпилируйте код. Вы увидите новые файлы `.js.map`.
13. **Добавьте точки останова (Breakpoints):**
    - Откройте ваш `.ts` файл и добавьте некоторую логику.
    - Вставьте точки останова, нажав на номер строки. Точки останова приостанавливают выполнение кода.
14. **Создайте файл `launch.json`:**
    - Откройте панель отладки (Debug Panel).
    - Создайте файл `launch.json`.
    - Из выпадающего списка выберите `Node.js`. Этот файл настраивает VS Code для отладки, указывая, что вы будете использовать NodeJS для запуска и отладки программы.
15. **Добавьте задачу `preLaunchTask`:**
    - В `launch.json` добавьте `preLaunchTask` и установите его в `tsc build -p tsconfig.json`. Это указывает VS Code использовать компилятор TypeScript для сборки вашего приложения.
16. **Начните отладку:**
    - Вернитесь к вашему `.ts` файлу.
    - Откройте панель отладки и нажмите "Launch Program" или используйте `F5`.
    - Программа запустится и остановится на точке останова.
17. **Используйте инструменты отладки:**
    - `F10` (Step over): выполняет одну строку кода.
    - `Step into`: полезно для функций.
    - `Step out`: полезно для выхода из функций.
    - `Restart`: перезапускает сессию отладки.
    - `Stop`: завершает отладку.
18. **Наблюдайте за переменными:**
    - В левой части панели отладки, в разделе "Variables", вы можете видеть обнаруженные переменные и наблюдать за их изменениями. Вы также можете добавить переменные в окно "Watch".
19. **Использование `console.log`:** Добавление `console.log` также помогает видеть эффект во время отладки.

