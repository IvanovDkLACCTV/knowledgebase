
## Место фронта в общей архитектуре приложения

Фронтенд отвечает за взаимодействие с пользователем и служит «мостом» между моделью данных и презентацией. Он получает данные из бэкенда (API, БД), обрабатывает их и отображает в UI.

- **Clean Architecture**: разделение на слои (Entities, Use Cases, Interface Adapters, Frameworks), где фронт оказывается на уровне «Interface Adapters» и «Frameworks».
- **MVC (Model-View-Controller)**: фронт в роли View, а иногда Controller, взаимодействующий с Model через API.
- **MVP (Model-View-Presenter)**: фронтенд реализует View, которая максимально «глупая» и отвечает только за отображение. Вся логика взаимодействия с моделью и обработка событий пользователя делегируется Presenter'у, который не зависит от UI-фреймворка и легко тестируется. Такой подход часто используется в мобильной разработке и в сложных UI-формах.
- **MVVM (Model-View-ViewModel)**: фронт реализует View и ViewModel, где ViewModel содержит состояние и бизнес-логику, а View подписывается на изменения через двустороннюю привязку данных (data binding). Особенно популярен в экосистемах с реактивным подходом — например, в Angular, Vue или Jetpack Compose.

---

Вот отличное видео о сравнении разных подходов к архитектуре фронтенд приложений:  
https://youtu.be/2DFq_Oi1w4o?si=Eg5SqsFtN5fW2v-Q

Давайте разберём каждую из них по порядку.

## Модульная архитектура (Modular Architecture)

Модульная архитектура предполагает деление кода на независимые, чётко определённые блоки (модули). Каждый модуль имеет свою ответственность, скрывает внутреннюю реализацию и экспортирует API:

- изоляция: изменения внутри модуля не влияют на другие;
- переиспользование: модули можно подключать в разных приложениях;
- тестируемость: независимые юнит-тесты для каждого модуля.

Официальная документация по принципам модульности (Martin Fowler):  
https://martinfowler.com/articles/structure-principles.html

ASCII-схема типичной структуры модульного приложения:

```
app/
├── modules/
│   ├── auth/
│   │   ├── api.js
│   │   ├── ui.js
│   │   └── utils.js
│   ├── dashboard/
│   │   ├── api.js
│   │   ├── ui.js
│   │   └── hooks.js
│   └── shared/
│       ├── components/
│       └── utils/
└── index.js
```

С данным подходом мы все сталкивались, когда только начинали проект из шаблона, предоставляемого сборщиком проектов или иным инструментом для развёртки приложения. Этот архитектурный паттерн отлично подходит для небольших проектов.

---

## Atomic Design

Подход Atomic Design (Brad Frost) строит интерфейс по принципу «атомы → молекулы → организмы → шаблоны → страницы»:

- Атомы: базовые элементы (кнопки, поля, заголовки).
- Молекулы: комбинации атомов с конкретной логикой (поле с лейблом и валидацией).
- Организмы: сложные блоки страницы (шапка, карточка товара).
- Шаблоны: макеты, собирающие организмы в структуры.
- Страницы: конечные представления с данными.

Официальный сайт Atomic Design:  
https://atomicdesign.bradfrost.com

ASCII-диаграмма уровней:

```
[ Page ]
   │
[ Template ]
   │
[ Organism ]
   │
[ Molecule ]
   │
[ Atom ]
```

На практике этот подход используется редко, но до появления FSD, служил отличной альтернативой для него. Лично я сталкивался с этим подходом только когда использовал менеджер состояния [Jotai](https://jotai.org/docs).

---

## Feature-Sliced Design (FSD)

FSD организует фронтенд-проект по фичам и слоям, каждая фича — независимый набор UI, логики и API-запросов:

- Layers (слои):  
    – app (точка входа, роутинг)  
    – pages (страницы бизнес-логики)  
    – widgets (набор готовых UI-модулей)  
    – features (отдельные фичи приложения)  
    – entities (бизнес-сущности)  
    – shared (общие утилиты, UI-компоненты)
    
- Domains and Slices: внутри каждого слоя фичи группируются по доменам.
    

Официальная документация FSD:  
https://feature-sliced.design/docs/introduction

ASCII-схема FSD:

```
app/
├── pages/
│   ├── HomePage/
│   │   ├── index.tsx
│   │   └── model/
│   └── ProfilePage/
├── widgets/
│   ├── UserCard/
│   └── NotificationBell/
├── features/
│   ├── Auth/
│   └── Cart/
├── entities/
│   ├── User/
│   └── Product/
└── shared/
    ├── ui/
    └── lib/
```

В данный момент именно этот подход стал стандартным для архитектуры крупных приложений, так как позволяет разделить проект на сущности максимально приближено к [компонентой модели](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) [объектно-ориентированного программирования](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5). 
Каждая фича имеет собственную вложенность UI и model-слой, что упрощает поддержку и расширение крупных приложений.

---

### Сравнение подходов

|Подход|Описание|Плюсы|Минусы|
|---|---|---|---|
|Модульная|Организация кода по автономным модулям с чёткой ответственностью и собственным API; каждый модуль скрывает реализацию и взаимодействует через интерфейс|- Изоляция изменений внутри модуля<br>- Повторное использование в разных проектах<br>- Упрощённое тестирование|- Избыточность слишком мелких модулей<br>- Риск разрастания количества папок и файлов|
|Atomic Design|Разбиение UI-компонентов на атомы → молекулы → организмы → шаблоны → страницы; фокус на визуальные и интерактивные элементы интерфейса|- Ясная иерархия компонентов<br>- Высокая повторная использованность UI<br>- Лёгкое прототипирование|- Слабая привязка к доменной логике<br>- Требует дополнительных паттернов для разделения бизнес-слоя|
|Feature-Sliced Design|Организация по слоям (app, pages, widgets, features, entities, shared) с группировкой внутри фич и доменов; каждая штука — отдельный срез функционала|- Чёткое разграничение ответственности по фичам и доменам<br>- Хорошо масштабируется на больших кодовых базах<br>- Удобно для командной работы|- Высокий порог входа: требует настроить структуру заранее<br>- Нужно дисциплинированное соблюдение соглашений|

---

## Что почитать

- Официальные статьи Martin Fowler про модульность и контрактное программирование.
- Atomic Design Handbook от Brad Frost.
- Документация Feature-Sliced Design с кейсами мобильных и веб-проектов.

---

А теперь не много подробнее про модульную архитектуру и FSD.

## 1. Модульная архитектура (Modular Architecture)

### 1.1 Основные принципы

- **Изоляция ответственности**  
    Каждый модуль решает одну задачу (авторизация, профиль, каталог).
- **Явный публичный API**  
    На входе — чётко определённый набор экспортируемых функций/компонентов, на выходе — ничего лишнего.
- **Слабая связь**  
    Модули не зависят напрямую друг от друга, а общаются через контракты (интерфейсы).
- **Повторное использование**  
    Изолированные модули легко перенести в другие проекты или вынести в npm-пакеты.
- **Тестируемость**  
    Локальные юнит-тесты охватывают модуль без подгрузки всего приложения.

### 1.2 Типовая структура папок

```
src/
├── modules/
│   ├── auth/
│   │   ├── api.ts          # HTTP-запросы и контракты
│   │   ├── hooks.ts        # Кастомные React-хуки
│   │   ├── components/     # UI-компоненты формы логина
│   │   └── index.ts        # Публичный API модуля
│   ├── profile/
│   │   ├── service.ts
│   │   ├── components/
│   │   └── index.ts
│   └── shared/
│       ├── Button.tsx
│       ├── Modal.tsx
│       └── utils.ts
└── app/
    └── index.tsx           # Точка входа, роутинг, провайдеры
```

- Каждый `modules/<name>/index.ts` собирает и реэкспортирует то, что нужно внешнему коду.
- Папка `shared/` содержит утилиты и компоненты без внутренней логики.

### 1.3 Расширенные паттерны

1. **Версионирование модулей**  
    src/modules/auth/v1/_, src/modules/auth/v2/_ — удобно при изменении контрактов.
2. **Динамическая подгрузка**
    
    ```ts
    const AuthModule = React.lazy(() => import('modules/auth'));
    ```
    
3. **Пакетирование**  
    Выносить модули в отдельные библиотеки (mono-repo + pnpm workspaces, Turborepo).
4. **Feature Flags внутри модулей**  
    Управлять включением новых возможностей локально, без правки внешнего кода.

### 1.4 Преимущества и подводные камни

|Плюсы|Минусы|
|---|---|
|Лёгко тестировать и отлаживать каждый модуль|Требует дисциплины: строгие контракты и документация|
|Повторное использование|Может возникнуть «избыточное» дробление на мелкие модули|
|Ясные границы зависимости|Без автоматизации обновления контрактов — «адовая» интеграция|

---

## 2. Feature-Sliced Design (FSD)

### 2.1 Концепция и мотивация

FSD фокусируется не на технических слоях, а на **бизнес-логике (фичах)** (*совокупности правил и принципов обработки данных, которые отражают уникальные требования и процессы конкретного бизнеса или предметной области. Она реализует ключевые операции над данными, отделяя их от технических аспектов хранения, передачи и отображения информации*) и её иерархии:

- **Layers (слои)** отражают уровни ответственности  
    app → pages → widgets → features → entities → shared
- **Slices (срезы)** внутри каждого слоя группируют связанные фичи по доменам
- **Segments** внутри каждой фичи выделяют более мелкие бизнес-процессы

### 2.2 Слои и пример структуры

```
src/
├── app/                # Инициализация, роутинг, глобальные провайдеры
│   └── index.tsx
├── pages/              # Конкретные экраны с привязкой к URL
│   ├── HomePage/
│   │   ├── ui.tsx
│   │   └── model.ts
│   └── ProfilePage/
│       ├── ui.tsx
│       └── model.ts
├── widgets/            # Переиспользуемые UI-блоки на уровне страниц
│   ├── UserCard/
│   │   ├── ui.tsx
│   │   └── model.ts
│   └── NotificationBell/
├── features/           # Мелкие фичи, объединяющие UI и логику
│   └── auth/
│       ├── ui/
│       │   └── AuthForm.tsx
│       └── model/
│           └── authApi.ts
├── entities/           # Бизнес-сущности и их модели (User, Product)
│   ├── User/
│   └── Product/
└── shared/             # Общие библиотеки, утилиты, типы, ui-компоненты
    ├── ui/
    └── lib/
```

### 2.3 Правила зависимости

1. Код может импортировать файлы **своего** среза и **нижнего** (shared ← entities ← features ← widgets ← pages ← app).
2. **Нельзя** перескочить через слой: `features/*` не импортирует из `pages/*`.
3. **Публичный API** у каждого среза (`index.ts`) должен быть минимальным.

### 2.4 Названия и соглашения

- Папки именуются **с заглавной буквы**: `Features`, `Entities`.
- Каждый срез держит внутри: `ui/`, `model/`, `api/`, `lib/`.
- Файлы `index.ts` в корне среза экспортируют только то, что нужно другим слоям.

### 2.5 ASCII-диаграмма FSD

```
src/app
└─ index.tsx

src/pages
├─ HomePage
│  ├─ ui.tsx
│  └─ model.ts
└─ ProfilePage
   ├─ ui.tsx
   └─ model.ts

src/widgets
├─ UserCard
│  ├─ ui.tsx
│  └─ model.ts
└─ NotificationBell
   ├─ ui.tsx
   └─ model.ts

src/features
└─ auth
   ├─ ui/AuthForm.tsx
   └─ model/authApi.ts

src/entities
├─ User
└─ Product

src/shared
├─ ui/Button.tsx
└─ lib/utils.ts
```

### 2.6 Преимущества и подводные камни

|Плюсы|Минусы|
|---|---|
|Логичная иерархия, отражающая бизнес-домены|Сложно начать: нужно заранее продумать структуру и обучить команду|
|Удобно масштабировать и разделять работу между командами|Поддержка файловой структуры требует линтинга и CI-правил|
|Явные слои и публичные API упрощают рефакторинг и тесты|Иногда слишком «многословно» для прототипов|

---

## 3. Сравнение модульной архитектуры и FSD

|Фактор|Модульная архитектура|Feature-Sliced Design|
|---|---|---|
|Гранулярность|Модули любым размером, важно чётко определять API|Жёсткая иерархия слоёв и срезов|
|Организация|По функциональным зонам (auth, profile, shared)|По слоям (app, pages, widgets, features, entities, shared)|
|Гибкость|Очень гибкая, но риски «разрастания папок»|Строгие правила,но ясные границы|
|Крутая настройка|Старт «быстрый» — просто создать папку и index.ts|Требует initial boilerplate и соглашений|
|Идеальные сценарии|Когда нужно быстро выделить повторяющиеся части|Крупные проекты с несколькими командами, активным ростом фич|

---

