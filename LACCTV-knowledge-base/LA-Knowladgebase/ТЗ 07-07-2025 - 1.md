# Архитектура и стек технологий

- **Backend (самохостинг): Supabase.** Открытый backend-as-a-service на основе PostgreSQL, обеспечивающий аутентификацию (GoTrue), хранилище данных и RLS-логику ролей пользователей. Supabase выбрано как масштабируемая платформа с готовыми инструментами (PostgREST, Realtime, Storage) и полным доступом к Postgres.
    
- **Frontend (PWA): Next.js + Tailwind CSS.** Используем Next.js для создания PWA-приложения с одним кодовым базисом для веба, что упрощает кросс-платформенную разработку. Next.js позволяет создавать прогрессивные веб-приложения («app-like») без затрат на отдельные нативные приложения. Tailwind CSS обеспечивает быстрый стилизованный фронтенд.
    
- **Мобильное приложение: React Native (Expo) + NativeWind.** Основной функционал «базы знаний» дублируется в мобильном приложении, плюс доступ к камере для распознавания данных. NativeWind (аналог Tailwind CSS для React Native) позволяет использовать знакомый utility-first подход для стилей.
    
- **Состояние: Zustand + SWR.** Лёгкий глобальный стор Zustand (≈1.5KB, удобное API) вместе с SWR для асинхронной загрузки данных помогает избежать громоздкого Redux. SWR реализует стратегию «stale-while-revalidate» с кешированием и повторной валидацией. Вместе они снижают накладные расходы на коммуникацию и ускоряют реактирование компонентов.
    
- **Telegram-бот (Python).** Отдельный сервис на Python (например, с использованием `python-telegram-bot` или `aiogram`), подключённый к общей БД Supabase через REST API или библиотеку (наличие готовых Python-клиентов к Supabase). Бот выполняет поиск инструкций, сбор отчётов и диагностику неполадок. Существуют фреймворки (например, grammY для Node.js) для упрощения работы с Telegram Bot API, аналогично в Python.
    
- **Архитектурный стиль: Feature-Sliced Design (FSD).** Фронтенд-разработка организована по «фичам»: каждый функциональный модуль (просмотр инструкции, чеклист, отчёт и т.д.) – отдельная «среза» с уровнями (UI, модели, сервисы). Это усиливает инкапсуляцию и переиспользование компонентов, упрощает масштабирование и поддержку проекта.
    
- **Монолит с модулями (modular monolith).** Код хранится в едином репозитории (моно-репо), но логически разделён на независимые модули (фичи). Такая архитектура сочетает простоту монолита и гибкость микросервисов. Модули имеют чёткие границы и общаются через API, что впоследствии позволит выделять отдельные сервисы при необходимости.
    
- **Монорепозиторий: Turborepo + Workspaces.** Структура репо основана на Turborepo (pnpm/Yarn Workspaces) с разделением на папки `apps/` (PWA, mobile, bot) и `packages/` (shared-библиотеки, утилиты). Например, в `apps/pwa` – код Next.js PWA, в `apps/mobile` – React Native приложение, в `apps/bot` – код Telegram-бота, а в `packages/shared` – общие React-компоненты, хуки, типы. Такой подход ускоряет сборку и переиспользование кода.
    

> Подходы и инструменты: Figma для UI-дизайна, Miro для совместных диаграмм и mindmap (Miro часто используют для визуализации архитектур), Obsidian – как хранилище технической документации (персональная база знаний с графом заметок).

## Платформы и функциональность

- **Telegram-бот:** Поиск инструкций по ключевым словам, формирование отчётов о работах и диагностика неисправностей по параметрам. Бот обращается к базе Supabase для чтения инструкций и записи данных отчётов в БД.
    
- **PWA (Next.js):** Основной интерфейс «базы знаний», включающий: каталог инструкций, интеллектуальный поиск по тексту, чеклисты и акты ремонтов, админ-панель, аналитику. Также в PWA выполняется распознавание текстовых данных (VIN, госномеров) через модуль машинного зрения.
    
- **Мобильное приложение:** Повторяет функционал PWA с упором на офлайн-возможности и работу с камерой. Камера используется для live-сканирования VIN/SN/номеров машин, а также доступа к галерее для загрузки фотографий (например, чеклиста или акта).
    
- **Общие функции:** Единая авторизация и система ролей через Supabase Auth. Разграничение прав (скрыть/показать функции) на фронтенде и в базе через RLS. Синхронизация состояния между приложениями через Zustand+SWR.
    

## Структура директорий (прим. схемы проекта)

|**Путь (пакет)**|**Назначение**|
|---|---|
|`apps/pwa`|PWA-приложение на Next.js (база знаний, админка, аналитика, OCR)|
|`apps/mobile`|React Native (Expo) приложение (все функции PWA + камера)|
|`apps/bot`|Telegram-бот (Python-сервис для инструкций/отчетов)|
|`packages/shared`|Общие библиотеки: UI-компоненты React, хуки, утилиты, конфигурации|
|`packages/backend`|Конфигурация Supabase (SQL-скрипты, миграции, функции)|
|`packages/state`|Zustand-хранилище и SWR-конфигурации общего пользования|
|`turbo.json`, `pnpm-workspace.yaml`|Конфиги Turborepo/Workspaces|

## План разработки

1. **Монорепозиторий и окружение:** Настроить Turborepo-монорепозиторий: создать папки `apps`/`packages`, настроить `pnpm-workspace.yaml` и `turbo.json`. Развернуть Supabase в self-host режиме (Docker) для хранения БД и Auth.
    
2. **Авторизация и роли:** Реализовать аутентификацию через Supabase Auth (JWT). Определить схемы данных: таблицы пользователей, ролей, связи. Настроить RLS-политики для разграничения доступа к таблицам инструкций и отчётов.
    
3. **База знаний и чеклисты:** Разработать модель данных инструкций (название, контент, категория, файлы). Реализовать загрузку и отображение инструкций в PWA/Mobile. Добавить полнотекстовый/семантический поиск (например, встроенный поиск Postgres или MeiliSearch). Вести версионирование или драфты инструкций при необходимости. Добавить формирование и хранение чеклистов.
    
4. **Интеллектуальный поиск:** При необходимости подключить векторный поиск/LLM (ChatGPT API или собственное решение) для более «умного» поиска по ключевым словам и синонимам.
    
5. **Админ-панель:** Сделать интерфейс управления пользователями, ролями и инструкциями (CRUD). Можно использовать отдельное Next.js-приложение (`apps/pwa/admin`) либо защитить раздел админки в PWA. Авторизация через Supabase позволяет легко ограничить доступ.
    
6. **Неисправности, акты ремонтов, отчёты:** Ввести таблицу «Неисправности» (словарь кодов) и «Акты ремонтов». Реализовать UI для создания актов (с привязкой к машине, проблемам, затраченным деталям). Добавить сводные отчёты по выполненным ремонтам (отчётность). Обеспечить возможность выгрузки актов в формате, требуемом внешней базой (см. пункт 7).
    
7. **Интеграция с внешней базой актов:** Если существует внешняя система актов, согласовать формат обмена (API или файлы). Настроить экспорт/импорт данных (например, по расписанию через edge-функции Supabase или скрипты на Python).
    
8. **Распознавание VIN/SN/госномеров:** Разработать модуль компьютерного зрения. Для фото-данных использовать OpenALPR (анализ номеров) или готовые сервисы OCR (например, Tesseract, либо коммерческие API). Для VIN в live-режиме применить OCR-алгоритм, обученный на образцах VIN-кодов. Гарантировать достаточную точность: предусмотреть валидацию распознанного текста по формату VIN. Сканирование номера автомобиля на фото можно реализовать через canvas на фронтенде или отправкой изображения на сервер для обработки.
    

Каждый этап разбить на подзадачи (unit-тесты, проверки, CI/CD). По окончании 8 этапа провести рефакторинг и подготовку к возможному выделению микросервисов (модули уже имеют изолированные границы).


