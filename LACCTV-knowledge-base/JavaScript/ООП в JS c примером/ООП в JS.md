Сегодня разберём вот этот короткий урок по ООП в JavaScript

![](https://youtu.be/Z7V4ZtiF8Uc?si=7dfXw9S2lJ0qME7G)


Видеоролик подробно рассматривает концепции **объектно-ориентированного программирования (ООП) в JavaScript**, начиная с общих стилей программирования и углубляясь в особенности реализации ООП, включая классы, наследование, инкапсуляцию, полиморфизм, статические члены и работу с прототипами.

### **1. Стили программирования в JavaScript**

Автор видео выделяет три основных стиля программирования, которые можно использовать в JavaScript:

- **Процедурный стиль**:
    
    - Код выполняется последовательно, шаг за шагом.
    - Пример: простая функция `Hello`, которая выводит "единичку" в консоль.
    - **Проблемы**: Часто приводит к созданию "Legacy" кода из-за отсутствия строгих правил и структуры, что затрудняет работу команды и поддержку проекта в долгосрочной перспективе.
- **Функциональный стиль**:
    
    - **Фокусируется на результате и данных**, а не на самом процессе их получения.
    - Пример: использование метода `filter` для массива, где важен результат фильтрации, а не внутренняя логика перебора.
- **Объектно-ориентированный стиль (ООП)**:
    
    - **Вводит определённые рамки и правила** для организации кода.
    - Цель ООП – решать проблемы "Legacy" кода, делая проекты более структурированными и понятными для новых разработчиков, хотя и с классами можно написать плохой код.

### **2. Классы в JavaScript (синтаксис ES6)**

JavaScript получил "синтаксический сахар" в виде классов, что значительно упростило работу с ними.

- **Объявление класса**: Используется ключевое слово `class`. Пример: `class Person`.
- **Конструктор (`constructor`)**:
    - Это специальная функция, которая **инициализирует новый экземпляр класса**.
    - Вызывается автоматически при создании нового объекта с помощью ключевого слова `new` (например, `new Person('Alex', 20)`).
- **Атрибуты (свойства)** и **Методы (функции)**:
    - **Атрибуты** – это переменные, принадлежащие экземпляру класса (например, `name`, `age`).
    - **Методы** – это функции, принадлежащие экземпляру класса (например, `print()`).
    - **`this`**: Ключевое слово, которое **ссылается на текущий контекст объекта**, в данном случае на экземпляр класса. Используется для установки атрибутов внутри конструктора или доступа к ним в методах (например, `this.name`, `this.age`).
    - **Пример использования**: Создание экземпляра `Alex` класса `Person` и вызов его метода `print` для отображения атрибутов.

### **3. Три столпа ООП**

Видео выделяет три основных принципа ООП: **наследование, инкапсуляция и полиморфизм**, а также упоминает композицию.

#### **3.1. Наследование**

- **Определение**: Позволяет новому классу (дочернему классу) наследовать свойства и методы от существующего класса (родительского класса).
- **Ключевое слово `extends`**: Используется для установления связи наследования. Пример: `class Person extends Animal`, где `Animal` — родитель, а `Person` — ребёнок. Дочерний класс `Person` унаследует все атрибуты и методы, объявленные в `Animal`.
- **Ключевое слово `super()`**:
    - **Вызывает конструктор родительского класса** из конструктора дочернего класса.
    - **Обязательно к использованию** в конструкторе дочернего класса, если родительский класс имеет свой конструктор и требует инициализации (например, `super(type)` для передачи типа животного).

#### **3.2. Инкапсуляция**

- **Определение**: Принцип сокрытия внутренней реализации объекта от внешнего мира, **ограничивая видимость атрибутов и методов**.
    
- **Модификаторы доступа (аналогия с другими языками)**:
    
    - **`public`**: Доступен внутри класса, извне класса и в дочерних классах. Это **поведение по умолчанию в JavaScript**, если не указано иное.
    - **`protected`**: Доступен только в самом классе и его дочерних классах. В стандартном JavaScript нет встроенного модификатора `protected`, но принято использовать префикс `_` (один нижний прочерк) для обозначения таких членов (например, `_card`), хотя это не даёт реальной защиты.
    - **`private`**: Доступен только внутри класса, недоступен даже в дочерних классах. В стандартном JavaScript ранее также не было встроенного модификатора `private`; принято было использовать `__` (два нижних прочерка), но это также не давало реальной секьюрности.
    - **Современный JavaScript**: В новых версиях JavaScript (ECMAScript 2022 и выше) появилась **возможность объявлять приватные поля и методы с помощью префикса `#`** (например, `#card`). Это обеспечивает реальную инкапсуляцию, делая их недоступными извне класса.
        - _Пояснение_: В документации TC39 (ответственный комитет за развитие JavaScript) есть предложения, которые затрагивают развитие классов и их возможностей, включая "Decorators", что указывает на постоянное развитие синтаксиса классов.
- **Геттеры (`get`) и Сеттеры (`set`)**:
    
    - Используются для **контролируемого доступа к приватным или инкапсулированным атрибутам**.
    - **Геттер** позволяет получить значение атрибута, возможно, с дополнительной логикой (например, `get cardNumber()` может вернуть только номер карты, скрывая CVC).
    - **Сеттер** позволяет установить значение атрибута, также с возможностью добавления логики валидации или трансформации (например, `set cardNumber(value)` для установки нового номера).

#### **3.3. Полиморфизм**

- **Определение**: Способность объектов разных классов реагировать на один и тот же вызов метода по-разному, в зависимости от их специфической реализации.
- **Пример с `runDirection`**: Метод `runDirection` может быть объявлен в родительском классе `Animal` и переопределён в дочернем классе `Person`. В `Person` он может вызывать родительскую реализацию (`super.run(direction)`) и добавлять свою уникальную логику, которая будет зависеть от переданных аргументов (например, бежать домой или к определённой точке).
- **Пример с фигурами**: Класс `Shape` имеет метод `draw()`. Дочерние классы `Circle`, `Triangle`, `Square` переопределяют `draw()` так, чтобы каждый рисовал соответствующую фигуру.

### **4. Статические атрибуты и методы**

- **Определение**: Члены класса, которые **принадлежат самому классу, а не его отдельным экземплярам**.
- Обычно это вспомогательные методы или общие для всех экземпляров класса свойства.
- **Объявление**: Используется ключевое слово `static` перед атрибутом или методом (например, `static region = 'Asia'`, `static help() { ... }`).
- **Доступ**: Доступ к статическим членам осуществляется через имя класса (например, `Person.region`, `Person.help()`), а не через экземпляр (`alex.region` не будет работать).
- **Важно**: Статические методы не имеют доступа к контексту экземпляра (`this`).

### **5. ООП под капотом: Прототипы в JavaScript (ES5)**

Видео подчёркивает **фундаментальное отличие JavaScript**: в нём **нет "настоящих" классов** в том смысле, как в других языках (например, Java, C++). Классы ES6 – это **синтаксический сахар** над функциями и прототипами.

- **Исторический контекст**: Стандарт ECMA-262, 3-я редакция (1999) уже описывал базовые концепции **"Конструктора"** и **"Прототипа"** как ключевые элементы языка. Это подтверждает, что **прототипы являются основой объектной модели JavaScript**.
- **Конструктор-функция (в ES5-стиле)**:
    - Вместо ключевого слова `class` использовались обычные функции, которые вызывались с `new` и выполняли роль конструкторов (например, `function Person2(name, age) { this.name = name; this.age = age; }`).
    - Эта функция неявно возвращает `this` (новый экземпляр).
- **Свойство `prototype`**:
    - Это свойство, которое **присутствует только у функций и классов**. Оно используется для **добавления методов и атрибутов, которые будут доступны всем экземплярам** этого класса/конструктора.
    - Пример: `Person2.prototype.print = function() { ... }`.
    - **Важно**: Методы, добавляемые к `prototype`, должны быть обычными функциями (не стрелочными), чтобы корректно работал контекст `this`.
- **Свойство `__proto__` (или `[[Prototype]]`)**:
    - Это **внутреннее свойство, которое есть у _всех объектов_ в JavaScript**. Оно указывает на **прототип (родительский объект)**, от которого данный объект наследует свойства и методы.
    - Когда вы пытаетесь получить доступ к свойству или методу объекта, JavaScript сначала ищет его на самом объекте. Если не находит, он ищет его по цепочке прототипов (`__proto__`), пока не найдёт или не дойдёт до конца цепочки.
    - Пример: `(11).toString()` работает, потому что `toString` находится в `Number.prototype`, на который ссылается `__proto__` числового примитива.
    - Справедливо: `instance.__proto__ === Constructor.prototype`.
    - _Примечание_: Хотя `__proto__` широко используется для демонстрации, стандартом предпочтительнее использовать `Object.getPrototypeOf()` и `Object.setPrototypeOf()` для работы с цепочкой прототипов.
- **Наследование в ES5-стиле (через прототипы)**:
    - **Создание родительского конструктора**: `function Animal2(type) { this.type = type; }` и его методов: `Animal2.prototype.run = function() { ... }`.
    - **Вызов родительского конструктора**: Из дочернего конструктора `Person2` вызывается `Animal2.call(this, type)`. Метод `call` позволяет вызвать функцию с указанным контекстом `this`, что имитирует `super()`.
    - **Наследование методов прототипа**: `Person2.prototype = Object.create(Animal2.prototype)`. Эта строка создаёт новый объект для `Person2.prototype`, который будет иметь `Animal2.prototype` в качестве своего прототипа, таким образом `Person2` наследует методы `Animal2`.
    - **Корректировка свойства `constructor`**: После `Object.create`, свойство `Person2.prototype.constructor` будет указывать на `Animal2`. Его нужно явно переустановить на `Person2`: `Person2.prototype.constructor = Person2`.
- **Статические члены в ES5-стиле**:
    - Просто **прикрепляются непосредственно к функции-конструктору** (которая является классом в ES5-стиле), а не к её прототипу. Пример: `Person2.region = 'Asia'`, `Person2.help = function() { ... }`.
- **Инкапсуляция с `Object.defineProperty` (ES5)**:
    - Метод `Object.defineProperty(obj, prop, descriptor)` позволяет **детально управлять атрибутами свойств** объекта.
    - **Дескриптор свойства** включает:
        - `configurable`: `true` позволяет изменять дескриптор свойства или удалять его.
        - `writable`: `true` позволяет изменять значение свойства оператором присваивания.
        - `enumerable`: `true` позволяет свойству быть перечисленным при итерации по объекту (например, `for...in`).
        - `value`: Само значение свойства (для свойств данных).
        - `get` / `set`: Функции геттера и сеттера (для свойств-аксессоров).
    - _Пояснение_: В ECMA-262, 3-й редакции уже были определены "Атрибуты свойства", что указывает на существование концепции метаданных свойств до появления `Object.defineProperty` в ES5, которое дало программный контроль над ними.
- **Резюме по прототипам**: В JavaScript **нет классической классовой модели**, вместо этого используется **прототипное наследование**. Классы ES6 — это всего лишь **синтаксический сахар**, упрощающий работу с прототипами и конструктор-функциями, что было подтверждено ECMA-262.

**Список источников**: 

- [**"HTML5: A vocabulary and associated APIs for HTML and XHTML"** (W3C Working Draft 05 April 2011)](https://www.w3.org/TR/2011/WD-html5-20110405/)
- [**"TC39 - Specifying JavaScript."** (Информация о TC39 Ecma International и его роли в развитии JavaScript, включая текущие предложения)](https://tc39.es/)
- [**"V8 JavaScript engine"** (Высокопроизводительный движок JavaScript и WebAssembly от Google с открытым исходным кодом)](https://v8.dev/)
- [**"Весь ООП в JavaScript за 35 мин"** (Транскрипт видеоролика об объектно-ориентированном программировании в JavaScript)](https://youtu.be/Z7V4ZtiF8Uc?si=7dfXw9S2lJ0qME7G)
- [**"Стандарт ECMA-262, 3я редакция"** (Перевод стандарта ECMA-262, 3-е издание, 1999 г.)](https://javascript.ru/ecma)

**Пример**:

```html


```