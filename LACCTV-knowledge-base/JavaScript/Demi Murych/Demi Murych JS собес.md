![](https://youtu.be/vrfbB3Udntw?si=u67g3FuhH6qwnuk4)

Представленное видео содержит техническое собеседование JavaScript разработчика, проведенное Михаилом с Максимом Юрьевичем, известным как Demi Murych. Максим обладает более чем 30-летним опытом в IT и глубоким знанием спецификации JavaScript. В ходе собеседования затрагиваются как теоретические вопросы по JavaScript, так и практические задачи на код.

Ниже представлен конспект видео в формате "вопрос-ответ":

**1. Представление и опыт**

- **Вопрос (Михаил): Расскажи немного о себе.**
    - **Ответ (Максим):** Меня зовут Максим. Я учился 2,5 года в университете в 90-х годах по специальности **"автоматизация управления движением космическими аппаратами"**, но покинул его. Моя основная деятельность — **инжиниринг**, то есть решение задач по восстановлению логики чего-либо без исходной документации или кода. В JavaScript я попал в 2008-2009 годах, занимаясь реверсом веб-проекта, где столкнулся с JS-кодом и уязвимостями, связанными с языком. Последний раз я работал над большим самостоятельным проектом в 2014-2015 годах. С тех пор я в основном занимаюсь **оптимизацией кода**, поиском проблем в JS-коде. Мой начальный уровень знаний JavaScript тогда был **"ниже плинтуса"**. Первое разочарование постигло меня, когда я залез в спецификацию и понял, что многое из того, что обычно рассказывают о JavaScript, не соответствует реальности. Я дислексик, поэтому могу путать термины или забывать их.

**2. Теоретические вопросы по JavaScript**

- **Вопрос (Михаил): Какие знаешь виды объявления функции в JavaScript?**
    
    - **Ответ (Максим):** Есть возможность **декларирования функций** (Function Declaration) и **создания функционального объекта при помощи выражения** (Function Expression). Также есть **стрелочные функции**, которые отличаются поведением, связанным с `this`.
    - **Разница между Function Declaration и Function Expression:**
        - **Function Declaration:** Согласно спецификации, функция подготавливается к выполнению **до того**, как блок кода начал выполняться. Её можно вызвать до объявления (хостинг).
        - **Function Expression:** Подготовка к выполнению происходит **только в момент**, когда происходит связь между идентификатором и самой функцией. Её нельзя вызвать до объявления.
        - **Производительность:** Function Declarations нагружают интерпретатор на старте, так как все функции готовятся заранее, но имеют меньше издержек во время выполнения. Function Expressions имеют меньше издержек на старте, но больше при первом выполнении, когда интерпретатору нужно подготовить функцию.
- **Вопрос (Михаил): Стрелочные функции чем отличаются от других видов?**
    
    - **Ответ (Максим):** Основное отличие — **отсутствие логики переопределения `this`** в момент вызова. Стрелочная функция может быть объявлена только как Function Expression.
    - **Анонимные функции:** На собеседованиях стрелочные функции без имени часто называют анонимными. Однако, согласно спецификации, **анонимной функцией** считается любая функция без имени в момент декларации или выражения. При этом любая функция **всегда имеет имя** согласно специальному алгоритму назначения имени.
- **Вопрос (Михаил): Можем ли мы в стрелочных функциях обращаться к псевдомассиву `arguments`?**
    
    - **Ответ (Максим):** Не рекомендуется использовать `arguments` из-за **сложности оптимизации кода**. Максим давно его не использовал и не может сразу сказать, возможно ли это в стрелочных функциях.
    - **Дополнение:** Интервьюер отмечает, что это **невозможно**. Максим находит это любопытным, так как на уровне V8 стрелочная функция — это тот же код, что и обычная функция. `arguments` называется **"exotic object arguments"** в спецификации. Его использование нарушает работу большинства алгоритмов оптимизации кода, а его байткод в V8 выглядит **в 10 раз больше**.
- **Вопрос (Михаил): Можем ли мы вызывать стрелочные функции с помощью оператора `new` как конструктор?**
    
    - **Ответ (Максим):** **Нет**. `new` в спецификации — это выражение, а не оператор, и оно работает только с конструкторами. Из логики стрелочных функций вырезаны любые взаимодействия с `this`, что делает их непригодными в качестве конструкторов.
- **Вопрос (Михаил): Есть методы для перепривязки `this` (`call`, `apply`, `bind`)? В чём их разница?**
    
    - **Ответ (Максим):**
        - **`call`:** Первым аргументом принимает `this`, далее аргументы функции передаются через запятую.
        - **`apply`:** Первым аргументом принимает `this`, далее аргументы функции передаются **массивом**.
        - **`bind`:** Создает **новую функцию**, которая заранее привязывает определенные аргументы к исходной функции. Если вызвать `bind` на функции, у которой уже был привязан `this`, то `this` будет сброшен в пустой объект.
        - **Цепочка `bind`:** Можно вызывать цепочку `bind`, чтобы привязать оставшиеся параметры, но только те, которые еще не были определены.
- **Вопрос (Михаил): Какие типы данных в JavaScript существуют?**
    
    - **Ответ (Максим):** Традиционно ожидают "примитивные типы данных". В спецификации они делятся на **`object`** и **`non-object`**.
    - **Разница:** `object` по умолчанию возвращает структуру. Прочие типы по умолчанию возвращают примитивное значение (`primitive value`), хотя они также могут быть представлены в виде объекта.
    - **Количество типов:** Максим вспоминает 8 основных типов: `string`, `number`, `symbol`, `bigint`, `null`, `undefined`, `object`, `boolean`. Упоминает, что цифра 12 может быть связана с 12 дополнительными типами в `TypedArray`.
- **Вопрос (Михаил): Откуда у примитивных типов данных есть какие-то методы (например, `5.toFixed()`)?**
    
    - **Ответ (Максим):**
        - **Социально одобряемый ответ:** В момент использования точечной нотации (например, `идентификатор.метод`), выполняется алгоритм, который вызывает соответствующий конструктор (`Number` для числа), создавая **временный объект-обертку (`type object`)**, у которого и присутствуют методы.
        - **Согласно спецификации/V8:** В V8 и других реализациях **всё является объектом**. Представление по умолчанию отличается: для `object` получаем типичную структуру, для `non-object` — примитивное значение.
        - **Истинные примитивы:** Единственными типами, которые действительно полностью соответствуют термину "примитивные", являются **`null` и `undefined`**, потому что они всегда ведут себя предсказуемо.
        - **Пример `Number`:** `Number` может вести себя по-разному. Например, `1 + 2 = 3` (интуитивное сложение), но бинарные операции (`1.1 ^ 2`) отбрасывают дробную часть (из-за стандарта IEEE 754 для чисел с плавающей точкой). Это означает, что `Number` не является полностью примитивным, поскольку его поведение не всегда предсказуемо.
- **Вопрос (Михаил): Расскажи про структуры данных `Map` и `Set`.**
    
    - **Ответ (Максим):**
        - **`Set`:** Хранит **уникальные значения** (ключи). Ключами могут быть только типы `object` или `symbol`.
        - **`Map`:** Хранит **пары ключ-значение**. Ключами может быть **любой тип данных** (не только объектные, Максим сначала забыл, но потом уточнил).
        - **Общая отличительная черта:** **Гарантируется порядок вывода ключей/информации** ровно в том порядке, в котором они были добавлены.
        - **Отличие от обычных объектов:** `Map` и `Set` — это особые объекты со своими методами для работы с данными. В обычном объекте в качестве ключа можно использовать только `string` и `symbol`.
- **Вопрос (Михаил): Какие знаешь отличия `var`, `let` и `const`?**
    
    - **Ответ (Максим):**
        - **Область видимости (социально одобряемый ответ):** `var` имеет **функциональную область видимости**, `let` и `const` — **блочную**.
        - **Согласно спецификации:** Нет "областей видимости", есть **"окружения" (Lexical Environment)**. Существуют функциональные окружения и блочные окружения.
        - **Инициализация:**
            - **`var`:** Идентификатор связывается со значением (инициализируется `undefined`) в момент старта выполнения блока кода.
            - **`let`/`const`:** Идентификаторы декларируются, но находятся в **неинициализированном состоянии ("temporal dead zone")** до момента непосредственного связывания в коде.
        - **Повторное объявление:** `let` и `const` в одном блоке **не позволяют повторного объявления** одного и того же идентификатора.
        - **Иммутабельность (`const`):** `const` создает иммутабельную связь идентификатора со значением в пределах блока. За пределами блока тот же идентификатор `const` может быть переопределен.
        - **Производительность:** `var` более производителен. Интерпретатор обязан **анализировать весь JavaScript-бандл** от начала и до конца на предмет ошибок повторного объявления `let`/`const` **до момента начала исполнения кода**, даже если этот код никогда не будет выполнен. Это приводит к большим издержкам (performance impact). Ранее с `var` существовала **"ленивая компиляция"**, когда интерпретатор анализировал только ту часть кода, которая реально выполнялась.
- **Вопрос (Михаил): Расскажи про `Event Loop`.**
    
    - **Ответ (Максим):** `Event Loop` — это часть **стандарта HTML5** (для браузера), а не спецификации JavaScript.
    - **Назначение:** Позволяет реализовать базовую **асинхронность** выполнения кода.
    - **Основные очереди:**
        - **`Task Queue` (или `Callback Queue`):** В спецификации HTML5 называется `Task`, но подчеркивается, что **это не очередь** по историческим причинам. В неё попадают все задачи, которые не являются промисами, а также задачи из `setTimeout`/`setInterval`.
        - **`Microtask Queue` (или `Job Queue`):** В спецификации JS называется `Jobs` (Job Queue). Это **действительно очередь**. В неё попадают промисы и задачи, добавленные через `queueMicrotask`.
    - **Принцип работы:** Из `Task Queue` берется одна задача и выполняется. После этого **все** задачи из `Microtask Queue` выполняются строго по порядку. Затем браузер может произвести рендеринг страницы. И только после этого переходит к следующей задаче из `Task Queue`.
    - **Node.js:** В Node.js также есть `Event Loop`, работающий похожим образом, но не точно так же, как в HTML5.
- **Вопрос (Михаил): Сколько вообще потоков в JavaScript?**
    
    - **Ответ (Максим):** Зависит от хост-среды.
    - **Обычно:** Существует один **"Агент"** (экземпляр JavaScript-окружения) с одним потоком.
    - **Многопоточность:** Более 10 лет спецификация JS допускает создание нескольких таких "Агентов" (например, **Web Workers**), каждый со своим `Event Loop` и потоком. Они могут общаться через сообщения или общую память (Agent Cluster).
    - **Параллельность в одном `Event Loop`:** **Нет**, на уровне одного `Event Loop` JavaScript-код выполняется **последовательно**, даже если это код из нескольких вкладок браузера (хотя вкладки могут быть в разных физических процессах).
    - **Изменение в спецификации:** Спецификация JavaScript теперь позволяет "блокам" JS-кода выполняться **действительно параллельно** в разных физических потоках или процессах.
    - **Философия "однопоточности":** Вопрос об однопоточности JS устарел. Ранее он означал, что зацикленный скрипт мог "повесить" всю страницу. Сейчас, с появлением мультиагентной архитектуры, этот термин менее актуален, поскольку интерпретатор может распараллеливать вычисления.
- **Вопрос (Михаил): Расскажи про ключевое слово `this`. Как оно работает?**
    
    - **Ответ (Максим):**
        - **Социально одобряемый ответ:** `this` — это **контекст вызова метода** объекта.
        - **Согласно спецификации:** `this` — это **параметр** обычной (`Normal Function`), а не стрелочной, функции. Он назначается в зависимости от условий вызова этой функции и может быть связан с чем угодно (объектом, примитивным значением).
        - **Правила привязки:**
            - **Точечная нотация (`identifier.method()`):** `this` будет связан с идентификатором, который идет перед точкой.
            - **`call`/`apply`:** Могут напрямую привязывать `this` к любому значению, включая примитивные (начиная с ES2015), что прямо указывает на то, что `this` — это просто параметр.
- **Вопрос (Михаил): В чём разница между `__proto__` и `prototype`?**
    
    - **Ответ (Максим):**
        - **`__proto__`:** Недокументированная, нестандартная возможность, внедренная разработчиками браузеров для удобства доступа к **прототипу объекта**. В спецификации JS уже около двух лет красными буквами написано **"ни в коем случае не используйте `__proto__`"**, это возможность **`deprecated`** и будет удалена.
        - **`prototype`:** Это свойство **обычной функции**, которая может быть использована как конструктор. То, что связано с `prototype`, будет назначено в качестве прототипа объекту, созданному с помощью этого конструктора. **Прототипное наследование** — фундаментальная часть объектной архитектуры JS.
        - **Современный доступ к прототипам:** Используйте `Object.getPrototypeOf()`.
- **Вопрос (Михаил): `prototype` есть у каких-то определённых видов функций либо у всех объектов JS?**
    
    - **Ответ (Максим):** Прототип есть **вообще у любого объекта** в JavaScript, но не обязательно, что он будет связан с чем-либо осмысленным (может ссылаться на `null`). **Стрелочные функции не могут быть конструкторами**, соответственно, у них нет `prototype`. Свойство `prototype` функции задействуется только тогда, когда функция вызывается как конструктор с использованием `new`.
- **Вопрос (Михаил): Что такое Promise?**
    
    - **Ответ (Максим):** `Promise` — это **объект**, обладающий определенными свойствами. К нему привязывается дополнительная логика, результат которой может произойти в любое время после создания промиса, или не произойти никогда. Это инструмент для **отложенных вычислений**, позволяющий получать результат асинхронно. С помощью его методов (`then`, `catch`, `finally`) внешний код может подписаться на получение этого результата и прореагировать на него.
- **Вопрос (Михаил): Какие там у промиса есть три состояния?**
    
    - **Ответ (Максим):** `pending` (ожидание), `fulfilled` (получен результат), `rejected` (отклонён).
- **Вопрос (Михаил): Статические методы промисов?**
    
    - **Ответ (Максим):** `Promise.resolve()`, `Promise.reject()`, `Promise.all()`, `Promise.race()`.
- **Вопрос (Михаил): Как `Promise.all()` работает?**
    
    - **Ответ (Максим):** `Promise.all()` принимает на вход массив значений. Если значения не являются промисами, спецификация автоматически **обертывает их в промисы**. Внутренняя машинерия отслеживает выполнение всех промисов в списке. Как только **все промисы** переходят в состояние `fulfilled`, срабатывает соответствующий `then`-обработчик. Если **хотя бы один** промис в массиве переходит в состояние `rejected`, выполнение `Promise.all()` прерывается, и срабатывает `catch`-обработчик.
    - **Параллельное или последовательное выполнение:** `Promise.all()` **предполагает и позволяет параллельное выполнение** промисов, если внешние API (например, `fetch` в браузере) это поддерживают. Однако, если базовый внешний API является последовательным, `Promise.all()` также будет выполнять их последовательно.
- **Вопрос (Михаил): Можем ли мы как-то обработать состояние промиса не используя `catch`?**
    
    - **Ответ (Максим):** Да, метод `then()` принимает **два аргумента**: первый — колбэк для `fulfilled` состояния, второй — колбэк для `rejected` состояния.
- **Вопрос (Михаил): Замыкание в JavaScript — что это?**
    
    - **Ответ (Максим):**
        - **Социально одобряемый ответ:** **"Замыкание"** — это жаргонный термин, которого **не существует в спецификации** JavaScript. Это машинерия, объясняющая правила доступа функции к идентификаторам, определенным **за пределами этой функции**.
        - **Согласно спецификации:** Это решается через **"цепочки окружений" (Lexical Environments)**.
        - **Принцип:** Благодаря тому, что функции в JS являются функциональными объектами, которые можно передавать и возвращать, возникает проблема: откуда брать данные для идентификатора, используемого функцией при вызове — из текущего момента вызова или из момента определения функции? В JavaScript функция получает доступ к идентификаторам, которые определялись **в момент её собственного определения**, а также к тем, что находятся выше по цепочке окружений.
        - **Механизм:** Если ссылка на функцию продолжает существовать (например, она возвращена из другой функции), то **цепочка окружений**, необходимая для существования этой функции, **сохраняется в памяти**. Это позволяет функции искать идентификаторы по этой цепочке окружений, существовавшей на момент её создания. Это и назвали замыканием. Если функция больше не нужна, цепочка окружений уничтожается.
- **Вопрос (Михаил): Только функции создают замыкание, или вообще всё?**
    
    - **Ответ (Максим):** Формально, **блоки** также создают замыкания (новые окружения), но их состояние нельзя сохранить и переиспользовать, как функции. **Всё, что создает новое окружение**, формально можно назвать замыканием.
    - **Виды окружений:**
        - **Функциональное окружение:** Создается для функциональных объектов, хранит идентификаторы.
        - **Блочное окружение (Lexical Environment):** Создается блоками кода. Они разрушаются в момент закрытия блока, то есть их состояние не сохраняется.
    - **Спецификация vs. сленг:** Важно не путать термин `Lexical Environment` из спецификации с обиходным "лексическим окружением", используемым для объяснения замыканий.
    - **Бессмысленность вопроса:** Максим считает вопрос "что всё является замыканием" бессмысленным, потому что термин "замыкание" не регламентируется спецификацией. Вопрос чаще задают, чтобы проверить понимание механизма доступа к внешним идентификаторам, а не для глубокой философской дискуссии.
- **Вопрос (Михаил): Какие знаешь способы, чтобы скопировать объект в JS (глубокие и неглубокие)?**
    
    - **Ответ (Максим):**
        - **Поверхностное копирование:** **Оператор спред (`...`)** — копирует ключ-значения на глубину не выше одного уровня. Также **`Object.assign()`**.
        - **Глубокое копирование:** В новой спецификации появился **`structuredClone`**. Можно написать свой собственный **рекурсивный алгоритм копирования**.
        - **`JSON.parse(JSON.stringify(obj))`:** Максим называет это "очевидным **костылем**". Он не задумывался для копирования объектов и не считается нормальным с точки зрения программирования.
        - **Философия копирования:** В языках с прототипным наследованием, таких как JavaScript, потребность в копировании объекта часто указывает на **ошибку в архитектуре**. Задачи, требующие глубокого копирования, очень узки и связаны с системным, а не прикладным программированием. Изначально в JS не было встроенных механизмов копирования, так как разработчики не видели в этом необходимости.
- **Вопрос (Михаил): Как мы можем проверить наличие какого-либо ключа в объекте?**
    
    - **Ответ (Максим):**
        - **`Object.keys()`**.
        - **`Object.hasOwn()`**.
        - **Оператор `in`:** Ищет ключ, в том числе, по цепочке прототипов.
- **Вопрос (Михаил): Как мы можем сделать объект или свойства объекта неизменяемыми?**
    
    - **Ответ (Максим):**
        - **`Object.freeze()`:** **Полностью замораживает** объект, запрещая изменение существующих свойств и добавление новых.
        - **`Object.seal()`:** Запрещает добавление новых свойств и удаление существующих, но **разрешает изменение значений** существующих свойств.
        - **`Object.preventExtensions()`:** Запрещает **добавление новых свойств**.
        - **Через прототип:** Спрятать оригинальный объект в качестве прототипа для пустого объекта, тогда изменения будут попадать в пустой объект, а оригинал останется неизменным.
        - **Через дескрипторы свойств:** У дескриптора есть свойство **`writable`**. Установка его в `false` запретит запись. Также можно использовать геттеры/сеттеры для контроля изменений.
        - **Производительность дескрипторов:** В V8 и других JS-движках **не рекомендуется использовать дескрипторы** для производительного кода, так как они создают большие проблемы с оптимизацией объекта.
- **Вопрос (Михаил): Какой механизм позволяет итерироваться по коллекциям или строкам?**
    
    - **Ответ (Максим):** **Итераторы и генераторы** — универсальный механизм. Также можно использовать написанные вручную циклы (`for...of`, `for...in`) и дополнительные методы, если они есть у объекта (`forEach`, `reduce`, `map`).
- **Вопрос (Михаил): Что такое Генератор?**
    
    - **Ответ (Максим):** Это механизм, использующий функцию `function*`, внутри которой работа кода может быть **прервана (`suspended`)** в любой момент с помощью ключевого слова **`yield`**. Результат `yield` проваливается наружу, а из внешней среды можно "разморозить" функцию и продолжить её выполнение с того же места. Генераторы используются для создания **контролируемых потоков выполнения** и для организации перебора данных. С их помощью можно эмулировать поведение `async/await`.
- **Вопрос (Михаил): Как работает сборщик мусора (Garbage Collector) в JavaScript?**
    
    - **Ответ (Максим):** В спецификации JavaScript **сборщика мусора не существует**; это задача хост-среды, которая реализует JS.
    - **Цель:** Автоматическое управление памятью, чтобы решать, какие данные больше не нужны и могут быть удалены.
    - **Основной принцип (Mark-and-Sweep, упрощенно):** Пока есть хотя бы одна ссылка на данные, GC их не трогает. Как только ссылок не становится, GC считает, что данные можно удалить.
    - **Современный GC (например, V8):** Намного сложнее. Он уже давно выполняется **минимум в одном параллельном потоке**. Не все данные удаляются сразу, даже если ссылок на них нет (например, строковые значения могут храниться до последнего, так как они часто переиспользуются). Современный GC делит память на **"early Map" (молодая память)** и **"Old Space Map" (старая память)** и работает с ними по-разному.
- **Вопрос (Михаил): Расскажи про `requestAnimationFrame`.**
    
    - **Ответ (Максим):** Это не JavaScript, а **внешний API стандарта HTML5** (браузера).
    - **Цель:** Решить проблему производительности, связанную с **"reflow"** (полная перерисовка страницы) при изменении DOM-дерева.
    - **Принцип работы:** Коллбэк, привязанный к `requestAnimationFrame`, вызывается **после завершения отрисовки текущего кадра** (или перед отрисовкой, зависит от браузера). Любые изменения DOM-дерева внутри этого коллбэка **не приведут к немедленному `reflow`**, позволяя произвести пакетные изменения, которые будут отрисованы одним потоком при формировании следующего кадра.
    - **Применение:** Часто используется для **анимаций**, так как привязан к отрисовке каждого кадра. Однако его основная задумка — позволить программисту изменять DOM без постоянных перерисовок и перегрузки.
    - **Частота:** Вызывается с частотой отрисовки контента (например, 60 Гц), которая может варьироваться.
    - **`requestIdleCallback`:** Похожий API, но он вызывается, когда у браузера есть свободное время, и не привязан напрямую к формированию кадра.
- **Вопрос (Михаил): Чем отличаются примитивные типы данных от ссылочных?**
    
    - **Ответ (Максим):**
        - **Социально одобряемый ответ:** Объекты передаются **по ссылке** (изменения влияют на оригинал), примитивные типы передаются **по значению** (создается копия).
        - **Согласно спецификации:** **Абсолютно все типы передаются по ссылке**. В спецификации используется термин **"reference-like"** типы данных.
        - **Эксперимент:** Передача большой строки (примитивный тип) вложенными вызовами функций не приводит к увеличению потребления памяти, что подтверждает передачу по ссылке, а не по значению. Идентичные строковые значения часто ссылаются на одну и ту же область памяти.
        - **Собеседование:** Это "любопытный момент", где знание спецификации может идти вразрез с "социально одобряемым" ответом, что может быть воспринято как "плохие софт-скиллы". Однако знание реального поведения (reference-like) напрямую влияет на **эффективность кода** при работе с большими данными.
- **Вопрос (Михаил): Как с помощью кнопки в хедере засабмитить форму, которая находится в футере (кнопка не находится в теге формы)?**
    
    - **Ответ (Максим):** С помощью **JavaScript** можно повесить обработчик на кнопку и вызвать метод `submit()` у нужной формы.
    - **HTML (не JavaScript):** Максим не смог вспомнить прямой HTML-механизм для этого. Интервьюер подсказал про атрибут `form` у кнопки и `aria-owns`.

**3. Разбор практических задач**

Максим отмечает, что ненавидит такие задачи, потому что они проверяют запоминание **недетерминированного поведения** асинхронной машинерии, которая по своей сути создана для того, чтобы порядок выполнения не был строго предсказуем.

- **Задача 1: Предсказать вывод в консоль (`this` и стрелочные функции)**
    
    - **Код:**
        
        ```
        function foo() {
          const x = 10;
          const obj = {
            x: 20,
            bar: function() { console.log(this.x); },
            baz: () => { console.log(this.x); }
          };
          return obj;
        }
        
        const object1 = foo();
        object1.bar();
        object1.baz();
        
        const object2 = new foo();
        object2.x = 30;
        object2.bar();
        object2.baz();
        ```
        
    - **Объяснение (Максим):**
        - `object1.bar()`: `bar` — обычная функция, `this` привязана к `object1`. Выведет **20**.
        - `object1.baz()`: `baz` — стрелочная функция. `this` у стрелочных функций определяется лексически (из области видимости, где она была создана). Если `foo` вызывается глобально, `this` внутри `foo` будет глобальным объектом (`window` или `undefined` в строгом режиме). Вывод `this.x` может привести к ошибке или `undefined`. Однако, после демонстрации результата, Максим соглашается, что здесь также выведется **20**, что является неочевидным для стрелочной функции в таком контексте, указывая на тонкости поведения `this`.
        - `object2 = new foo()`: `foo` вызывается как конструктор, `this` внутри `foo` будет ссылаться на создаваемый экземпляр `object2`.
        - `object2.x = 30`: Присваивает свойство `x` экземпляру `object2`.
        - `object2.bar()`: `bar` — обычная функция, `this` привязана к `object2`. Выведет **20** (из `obj.x`).
        - `object2.baz()`: `baz` — стрелочная функция. `this` определяется лексически, то есть из контекста, где `foo` была вызвана конструктором. `this` внутри `foo` — это `object2`. Соответственно, `this.x` будет **30**.
    - **Итоговый вывод (по согласованию с результатом):** 20, 20, 30, 20.
- **Задача 2: `this` в методах класса (стрелочная vs. обычная) и `Object.assign`.**
    
    - **Код:**
        
        ```
        class Cat {
          constructor(name) {
            this.name = name;
            this.get_name_arrow = () => console.log(this.name);
          }
          get_name_regular() {
            console.log(this.name);
          }
        }
        
        const kitty = new Cat('Kitty');
        kitty.get_name_arrow();
        kitty.get_name_regular();
        
        const name_f = kitty.get_name_regular;
        name_f();
        
        const name_arrow_f = kitty.get_name_arrow;
        name_arrow_f();
        ```
        
    - **Объяснение (Максим):**
        - `kitty.get_name_arrow()`: `get_name_arrow` — стрелочная функция, её `this` лексически привязано к экземпляру `kitty` из конструктора. Выведет **'Kitty'**.
        - `kitty.get_name_regular()`: `get_name_regular` — обычная функция, `this` привязана к объекту, через который она вызвана (`kitty`). Выведет **'Kitty'**.
        - `name_f()`: `name_f` — это ссылка на обычную функцию `get_name_regular`. При вызове без точечной нотации `this` будет либо `undefined` (в строгом режиме), либо глобальным объектом (`window`). Выведет **`undefined`** (если `name` не определен глобально).
        - `name_arrow_f()`: `name_arrow_f` — это ссылка на стрелочную функцию `get_name_arrow`. `this` стрелочной функции уже был лексически привязан к `kitty` в момент её создания. Поэтому даже при таком вызове `this` останется `kitty`. Выведет **'Kitty'**.
    - **Итоговый вывод (по согласованию с результатом):** 'Kitty', 'Kitty', `undefined`, 'Kitty'.
- **Задача 3: Порядок вывода в консоль (Цепочки промисов)**
    
    - **Объяснение (Максим):** Максим выражает нелюбовь к таким задачам, так как они противоречат самой концепции асинхронности, но всё же пытается предсказать.
        1. **Синхронный код:** `console.log(1)` и `console.log(12)` выполняются первыми. Выведет: **1**, **12**.
        2. **Микротаски:** Далее выполняются микротаски, добавленные через `then()` или `catch()`.
            - `Promise.resolve().then(() => console.log(2))`: `console.log(2)` попадает в очередь микротасков. Выведет: **2**.
            - `Promise.resolve().then(() => console.log(5)).finally(() => console.log(8))`: `console.log(5)` попадает в очередь микротасков. Выведет: **5**. (Максим изначально предсказывал `8` после `5`, но `finally` тоже является микротаском).
            - `Promise.reject().catch(() => console.log(3))`: `console.log(3)` попадает в очередь микротасков, так как `catch` обрабатывает отклонённый промис. Выведет: **3**.
            - `Promise.reject().catch(() => console.log(9)).then(() => console.log(10)).finally(() => console.log(11))`: `console.log(9)` попадает в очередь микротасков. Выведет: **9**.
            - `Promise.resolve().then(() => console.log(13))`: `console.log(13)` попадает в очередь микротасков. Выведет: **13**.
    - **Итоговый вывод (по согласованию с результатом в видео):** 1, 12, 2, 5, 3, 9, 13. (Максим отмечает, что запутался с деталями поведения промисов при отклонённых состояниях и `catch`/`finally`, поскольку `catch` тоже возвращает новый промис, который может быть обслужен).
- **Задача 4: Наследование классов и `super`.**
    
    - **Код:**
        
        ```
        class Foo {
          constructor() {
            this.id = 'pro';
            this.print();
          }
          print() {
            console.log(this.id);
          }
        }
        
        class Bar extends Foo {
          constructor() {
            super();
            this.id = 'bar';
            this.print();
          }
          print() {
            console.log(this.id);
          }
          superprint() {
            super.print();
          }
        }
        
        const bar = new Bar();
        bar.superprint();
        ```
        
    - **Объяснение (Максим):**
        - При вызове `new Bar()`:
            - Вызывается конструктор `Bar`. Внутри него первым делом вызывается `super()`.
            - `super()` вызывает конструктор родительского класса `Foo`. Важно: **`this` внутри конструктора `Foo` будет ссылаться на экземпляр `Bar`**, который создается.
            - В конструкторе `Foo`:
                - `this.id = 'pro'`: Свойство `id` экземпляра `Bar` становится 'pro'.
                - `this.print()`: Вызывается метод `print` **экземпляра `Bar`** (поскольку `this` — это `Bar`-экземпляр). `Bar.print()` выведет `this.id`, который сейчас 'pro'. Вывод: **'pro'**.
            - Возвращаемся в конструктор `Bar`:
                - `this.id = 'bar'`: Свойство `id` экземпляра `Bar` теперь становится 'bar'.
                - `this.print()`: Вызывается метод `print` **экземпляра `Bar`**. Выведет `this.id`, который сейчас 'bar'. Вывод: **'bar'**.
        - После завершения конструктора: `bar.superprint()` вызывается:
            - `super.print()`: Вызывает метод `print` **родительского класса (`Foo`)**, но `this` при этом **привязывается к текущему экземпляру (`Bar`)**. `Foo.print()` выведет `this.id`, который сейчас 'bar'. Вывод: **'bar'**.
    - **Итоговый вывод (по согласованию с результатом в видео):** 'pro', 'bar', 'bar'.
- **Задача 5: Ссылки на объекты и их изменение.**
    
    - **Код:**
        
        ```
        const obj = { a: 1 };
        const arr = [obj];
        obj = null;
        console.log(arr);
        ```
        
    - **Объяснение (Максим):**
        - Идентификатор `obj` изначально связан со ссылкой на объект `{ a: 1 }`.
        - Массив `arr` создается и содержит **копию этой ссылки** на тот же объект `{ a: 1 }`.
        - `obj = null` **меняет ссылку**, хранящуюся в идентификаторе `obj`, на `null`. Это **не изменяет сам объект `{ a: 1 }`** в памяти.
        - Так как `arr` по-прежнему содержит ссылку на исходный объект `{ a: 1 }`, при выводе `arr` в консоль мы увидим массив, содержащий этот объект.
    - **Итоговый вывод:** `[ { a: 1 } ]`. Это иллюстрирует, что идентификаторы в JavaScript являются ссылочными.

**4. Обсуждение процесса собеседований**

- **Обратная связь по ответам (Михаил):** Ответы Максима правильны с точки зрения спецификации, но в реальном собеседовании для найма это может быть "ред флагом". Слишком глубокое знание, отличающееся от "социально одобряемых" ответов, может привести к отказу, поскольку работодателю может не понравиться "переделывание всего" или "другая точка зрения".
- **Подготовка к собеседованиям (Михаил):** Михаил готовит людей к собеседованиям, обучая их "шаблонам поведения" и "примерным паттернам ответа", чтобы они прошли этапы.
- **Пример отказа из-за софт-скиллов:** Михаил приводит пример кандидата, который отлично прошел технические этапы, но на финальном собеседовании (софт-скиллы) сказал, что интересуется мобильной разработкой. Ему отказали, потому что работодатель посчитал это риском ухода в будущем.
- **Итог по навыкам:** Максим и Михаил обсуждают, что технические навыки не всегда являются определяющими. Возможно, важен баланс 50/50 между техническими и "психологическими" (софт-скиллы) аспектами. Часто люди с большим опытом (10 лет) не могут ответить на "базовые" вопросы (например, по `Event Loop`), потому что не готовились к собеседованиям, в то время как люди с нулевым опытом, но хорошей подготовкой, быстрее получают офферы.
- **Этапы собеседований:** Обычно три этапа: скрининг (HR, базовые фильтры по резюме), техническое собеседование (несколько частей), и софт-скилл собеседование. В больших компаниях могут добавляться системный дизайн и алгоритмы.
- **"Правда" на собеседовании:** Обсуждение того, что "сейчас нельзя говорить правду на собеседовании". Нужно надевать "маску", а потом с этой маской идти работать. Максим выражает грусть по этому поводу, считая, что это ведет к "эмуляции" жизни.
- **Рынок труда:** Рынок перенасыщен, особенно для джуниоров. HR-рекрутеры используют автофильтры: например, резюме с опытом менее 3 лет могут быть автоматически отброшены без рассмотрения. Это заставляет людей "накручивать" опыт в резюме.
- **"Двойное сознание":** Чтобы быть успешным, специалист должен быть эффективным в практических задачах, но для прохождения собеседований ему нужны совершенно отдельные навыки, которые могут больше нигде не понадобиться.
- **"Бессмысленные" вопросы:** Максим снова подчеркивает, что вопросы типа "Покажи мне порядок вывода асинхронного кода" бессмысленны, так как сам инструмент (асинхронность) создан для недетерминированного поведения, и если нужен строгий порядок, нужно писать синхронный код.