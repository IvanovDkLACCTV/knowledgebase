## Ссылки на источники:

1. [Ссылка на видео](https://www.youtube.com/live/4tg4qokVS9o?si=XlZiKLG9AZmaQJS1)
2. [Ссылка на презентацию](https://docs.google.com/presentation/d/1LDJMSHmTkrYYdXQCinUIAQ9BMV2jIrctHhMfGSJDlXQ/edit?slide=id.g23f7e2e83e4_0_85#slide=id.g23f7e2e83e4_0_85)
3. [Ссылка на примеры кода](https://drive.google.com/drive/folders/1n8pXffdvd9DeNpeXGR8rBbFUM8Hxa_ms)

## Вкратце

### Что такое `this` в JavaScript?

- `this` в JavaScript — это не "контекст" и никогда им не был. Это обычный идентификатор, поведение которого очень похоже на поведение других идентификаторов, но с одним важным отличием: его значение может быть связано только особым способом вызова "нормальной" функции.
- Значение `this` в JavaScript зависит от одного основного фактора: **как и какая функция запускается (вызывается)**.

### Режимы работы (`use strict` и без него)

- Примеры в источниках преимущественно рассматриваются в **строгом режиме (`"use strict"`)**.
- В **строгом режиме** `this` всегда связан с тем значением, с которым он был связан, без неявных преобразований.
- В **нестрогом режиме (`non-strict mode`)**, если `this` связан с примитивным значением (например, числом, строкой), это значение **всегда будет преобразовано к объекту** перед тем, как будет использовано. Это происходит через виртуальную операцию `ToObject`.

### Определение `this` в зависимости от окружения

1. **Глобальное окружение (код вне функций)**:
    
    - Если код выполняется **внутри модуля**, `this` всегда равен **`undefined`**.
    - Если код выполняется **внутри скрипта** (не модуля), `this` по умолчанию связан с **глобальным объектом** (например, `window` в браузере). Однако, **хост-среда** (браузер, Node.js, D8) имеет право изменить это значение по своему усмотрению. Например, в Node.js `this` в глобальном окружении может быть пустым объектом.
    - Значение `this` в глобальном окружении редко используется на практике.
2. **Окружение функции (код внутри функций)**:
    
    - **Стрелочные функции (`arrow function`)**:
        - Стрелочная функция **не связывает свой собственный `this`**. Вместо этого, `this` внутри стрелочной функции определяется **лексическим окружением**, то есть значением `this` из родительской функции или глобального окружения, в котором она была **определена** (не вызвана).
        - Чтобы определить `this` в стрелочной функции, нужно "перейти к родительскому окружению" и начать алгоритм определения `this` заново, как будто стрелочной функции не существует.
    - **Нормальные функции (`normal function`)**:
        - Нормальная функция — это **любая функция, которая не является стрелочной функцией**.
        - По умолчанию, при вызове любой нормальной функции, `this` связывается со значением **`undefined`**.
        - Однако, это значение может быть изменено в зависимости от **формы или способа вызова** нормальной функции. Существует три основных способа, которые изменяют `this`:
            - **Явное задание (`call()`, `apply()`, `bind()`)**: Если функция вызывается с использованием методов `call`, `apply` или `bind`, `this` будет равен **значению, явно переданному в эти методы**. Это имеет наивысший приоритет.
            - **Вызов с `new`**: Если функция вызывается с ключевым словом `new` (например, `new doLogThis()`), `this` будет связан с **новым, пустым объектом**.
            - **Дот-нотация (`object.method()`)**: Если функция вызывается как метод объекта (т.е., `идентификатор.идентификатор()` или `идентификатор['идентификатор']()`), `this` будет равен **объекту, который стоит перед точкой**. Это очень частый случай в задачах на собеседованиях.
            - **В остальных случаях** (если не применяются `call`/`apply`/`bind`, `new`, или дот-нотация), `this` в строгом режиме будет **`undefined`**.

### Внешние API и `this`

- **Внешние API** (например, `setTimeout`, `addEventListener`) могут **связывать `this` с произвольным значением**, не подчиняясь стандартным правилам языка JavaScript.
- Поведение `this` в таких случаях определяется **спецификацией самого API** (например, HTML5 для `addEventListener`).
- Единственный способ гарантировать значение `this` при вызове через внешний API — это **явно привязать его с помощью `bind()`**.

### Итоги: Алгоритм определения `this`

1. **Где находится код?**
    - **Внутри функции?**
        - **Да:** Переходим к пункту 2.
        - **Нет:** Код в глобальном окружении.
            - **Модуль?** `this` = `undefined`.
            - **Скрипт?** `this` = глобальный объект (может быть изменен хостом).
2. **Какая функция?**
    - **Стрелочная функция?**
        - **Да:** `this` берется из **родительского (лексического) окружения** (где функция была определена), затем алгоритм начинается заново для родительского окружения.
    - **Нормальная функция?**
        - **Да:** Переходим к пункту 3.
3. **Как функция была вызвана?**
    - **`call()`, `apply()`, `bind()`?**
        - **Да:** `this` = **значение, переданное в метод**.
    - **`new`?**
        - **Да:** `this` = **новый пустой объект `{}`**.
    - **Дот-нотация (`object.method()`)?**
        - **Да:** `this` = **объект, стоящий перед точкой**.
    - **Ничего из вышеперечисленного?**
        - **Да:** `this` = **`undefined`** (в строгом режиме) или **глобальный объект** (в нестрогом режиме).

Этот алгоритм охватывает все случаи определения `this` в JavaScript и показывает, что его поведение является предсказуемым и строго определенным спецификацией, а не "магией" или "контекстом".
## Чуть подробнее

### Основные принципы `this` в JavaScript

Прежде всего, важно понять, что **`this` в JavaScript – это не "контекст" и никогда им не был**. Это обычный идентификатор, чье поведение очень похоже на поведение других идентификаторов, но с одним ключевым отличием: его значение может быть связано только особым способом вызова "нормальной" функции.

**Значение `this` в JavaScript зависит от одного основного фактора: как и какая функция запускается (вызывается)**.

### Режимы работы (`"use strict"` и без него)

Все приведенные в источниках примеры рассматриваются в **строгом режиме (`"use strict"`)**.

- В **строгом режиме (`"use strict"`)** `this` всегда связан с тем значением, с которым он был связан, без каких-либо неявных преобразований.
- В **нестрогом режиме (`non-strict mode`)**, если `this` связан с примитивным значением (например, числом, строкой), это значение **всегда будет преобразовано к объекту** перед тем, как будет использовано, через виртуальную операцию `ToObject`.

**Пример (нестрогий режим):** В нестрогом режиме, при вызове метода, привязанного к примитиву, `this` будет обернут в объект:

```
// string.prototype.doThing = function () {
//   console.log("this is:", this instanceof Object, this)
// };
// "Yo".doThing(); // this будет связан со значением new String("Yo")
// 12..doThing(); // this будет связан со значением new Number(12)
```

В строгом же режиме `this` в таких случаях останется примитивным значением.

### Определение `this` в зависимости от окружения

1. **Глобальное окружение (код вне функций)**:
    
    - **Если код выполняется внутри модуля**: `this` всегда равен **`undefined`**.
    - **Если код выполняется внутри скрипта** (не модуля): `this` по умолчанию связан с **глобальным объектом** (например, `window` в браузере). Однако **хост-среда** (браузер, Node.js, D8) имеет право изменить это значение по своему усмотрению. Например, в Node.js `this` в глобальном окружении может быть пустым объектом.
    
    **Пример (глобальное окружение):**
    
    ```
    "use strict";
    console.log("this is: ", this); // В strict mode в глобальном окружении модуля это будет undefined
    ```
    
    В глобальном окружении `this` используется крайне редко.
    
2. **Окружение функции (код внутри функций)**: С этого момента начинается самое интересное, поскольку **значение `this` изменяет именно вызов функции**.
    
    - **Стрелочные функции (`arrow function`)**:
        - **Стрелочная функция не связывает свой собственный `this`**.
        - Вместо этого, `this` внутри стрелочной функции определяется **лексическим окружением**, то есть значением `this` из родительской функции или глобального окружения, в котором она была **определена** (не вызвана).
        - Чтобы определить `this` в стрелочной функции, нужно "перейти к родительскому окружению" и начать алгоритм определения `this` заново, как будто стрелочной функции не существует.
    
    **Пример (стрелочная функция):**
    
    ```
    "use strict";
    
    function doLogThis() {
      var doArrowThing = (() => console.log("this is: ", this)); // Стрелочная функция
      doArrowThing();
    }
    doLogThis(); // Вызов doLogThis()
    ```
    
    В данном примере, при вызове `doLogThis()`, `this` внутри `doArrowThing` будет определяться как `this` для `doLogThis`. Поскольку `doLogThis` вызывается как обычная функция без `call`, `apply`, `bind` или dot-нотации, `this` внутри неё (и, соответственно, внутри стрелочной функции) будет **`undefined`** в строгом режиме.
    
    - **Нормальные функции (`normal function`)**:
        
        - Нормальная функция — это **любая функция, которая не является стрелочной функцией**.
        - **По умолчанию**, при вызове любой нормальной функции, `this` связывается со значением **`undefined`** в строгом режиме. Представьте, что у нормальной функции всегда есть скрытый аргумент `this`, который по умолчанию равен `undefined`.
        - Однако это значение может быть изменено в зависимости от **формы или способа вызова** нормальной функции. Существует три основных способа, которые изменяют `this`:
        
        1. **Явное задание (`call()`, `apply()`, `bind()`)**:
            
            - Если функция вызывается с использованием методов `call`, `apply` или `bind`, `this` будет равен **значению, явно переданному в эти методы**. Это имеет наивысший приоритет.
            - Можно передавать любые значения, включая примитивы, и `this` будет связан именно с ними.
            
            **Пример (явное задание `this`):**
            
            ```
            "use strict";
            
            function doLogThis() {
              console.log("this is: ", this);
            }
            
            var thisArg = { name: "thisArg" };
            doLogThis.call(thisArg);      // this будет { name: "thisArg" }
            doLogThis.apply(thisArg);     // this будет { name: "thisArg" }
            doLogThis.bind(thisArg)();    // this будет { name: "thisArg" }
            
            var thisArgPrimitive = "Yo";
            doLogThis.call(thisArgPrimitive); // this будет "Yo"
            ```
            
        2. **Вызов с `new`**:
            
            - Если функция вызывается с ключевым словом `new` (например, `new doLogThis()`), `this` будет связан с **новым, пустым объектом `{}`**.
            - Круглые скобки после имени функции при использовании `new` необязательны.
            
            **Пример (вызов с `new`):**
            
            ```
            "use strict";
            
            function doLogThis() {
              console.log("this is: ", this);
            }
            
            new doLogThis();  // this будет {} (новый пустой объект)
            new doLogThis;    // this также будет {} (новый пустой объект)
            ```
            
        3. **Дот-нотация (`object.method()` или `object['method']()`)**:
            
            - Если функция вызывается как метод объекта (т.е., `идентификатор.идентификатор()` или `идентификатор['идентификатор']()`), **`this` будет равен объекту, который стоит перед точкой**.
            - Это очень частый случай в задачах на собеседованиях.
            
            **Что такое Dot-нотация?** Дот-нотацией называют синтаксис, когда два идентификатора разделены между собой точкой (dot). Например, `theObj.theProperty`. Полным аналогом является синтаксис `theObj["theProperty"]`. Вызов функции в дот-нотации выглядит как `theObj.doThing()`.
            
            **Пример (дот-нотация):**
            
            ```
            "use strict";
            
            function doLogThis() {
              console.log("this is: ", this);
            }
            
            const theObj = {
              name: "Murych"
            };
            theObj.doLogThis = doLogThis; // Привязываем функцию как метод объекта
            theObj.doLogThis(); // this будет { name: "Murych", doLogThis: [Function: doLogThis] }
            ```
            
            В этом случае, `this` внутри `doLogThis` будет `theObj`.
            
        4. **В остальных случаях (без явного задания, `new` или дот-нотации)**:
            
            - `this` в строгом режиме будет **`undefined`**.
            - В нестрогом режиме `this` будет глобальным объектом.
            
            **Пример (вызов без особых форм):**
            
            ```
            "use strict";
            
            function doLogThis() {
              console.log("this is: ", this);
            }
            doLogThis(); // this будет undefined
            ```
            
            **Пример (потеря `this` при извлечении метода):**
            
            ```
            "use strict";
            
            const theObj = {
              name: "Murych",
              doLogThis: function () {
                console.log("this is: ", this);
              }
            };
            theObj.doLogThis(); // this будет { name: "Murych", doLogThis: [Function: doLogThis] }
            
            var doLogThisGlobal = theObj.doLogThis; // Извлекаем метод
            doLogThisGlobal(); // this будет undefined, так как вызов происходит не в дот-нотации
            ```
            

### Внешние API и `this`

- **Внешние API** (например, `setTimeout`, `addEventListener`) могут **связывать `this` с произвольным значением**, не подчиняясь стандартным правилам языка JavaScript.
- Поведение `this` в таких случаях определяется **спецификацией самого API** (например, HTML5 для `addEventListener` или Node.js для `setTimeout`).
- Единственный способ **гарантировать значение `this`** при вызове через внешний API — это **явно привязать его с помощью `bind()`**.

**Пример (`setTimeout`):**

```
"use strict";

const theObj = {
  name: "Murych",
  doLogThis: function () {
    console.log("this is: ", this);
  }
};

setTimeout(theObj.doLogThis, 1); // В браузере/V8 this будет undefined. В Node.js this может быть объектом Timer
```

В браузере или среде V8 вызов `theObj.doLogThis` через `setTimeout` приведет к тому, что `this` внутри `doLogThis` будет `undefined` (так как ссылка на функцию передается, и она вызывается не в дот-нотации). Однако в Node.js `this` может быть связан с объектом `Timer`, что обусловлено реализацией `setTimeout` в Node.js как внешнего API.

**Пример (`addEventListener`):**

```
"use strict";

function doHandleClick() {
  console.log("this is:", this);
}

document
  .body
  .addEventListener("click", doHandleClick); // this будет равен элементу body, а не undefined, согласно спецификации HTML5
```

Здесь, несмотря на то что `doHandleClick` вызывается не в дот-нотации, `this` будет указывать на `document.body`, потому что спецификация HTML5 для `addEventListener` явно привязывает `this` к элементу, на котором произошло событие.

### Краткий алгоритм определения `this`

1. **Находимся ли мы в коде функции?**
    
    - **Нет**: Это глобальное окружение.
        - **В модуле?** `this` = **`undefined`**.
        - **В скрипте?** `this` = **глобальный объект** (но может быть изменен хостом).
    - **Да**: Переходим к следующему шагу.
2. **Какая это функция?**
    
    - **Стрелочная функция (`arrow function`)?**
        - **Да**: `this` берется из **родительского (лексического) окружения** (где функция была _определена_), затем алгоритм начинается заново для родительского окружения.
    - **Нормальная функция (`normal function`)?**
        - **Да**: Переходим к следующему шагу.
3. **Как функция была вызвана?** (для нормальных функций)
    
    - **Через `call()`, `apply()`, `bind()` (Явное задание)?**
        - **Да**: `this` = **значение, явно переданное в метод**.
    - **С ключевым словом `new` (Вызов конструктора)?**
        - **Да**: `this` = **новый, пустой объект `{}`**.
    - **В дот-нотации (`object.method()`)?**
        - **Да**: `this` = **объект, стоящий перед точкой**.
    - **В остальных случаях (без вышеперечисленного)?**
        - **Да**: `this` = **`undefined`** (в строгом режиме). В нестрогом режиме — глобальный объект.

Этот алгоритм, основанный на спецификации, позволяет четко определить значение `this` в любой ситуации, без необходимости прибегать к метафорам "контекста" или "магии".

