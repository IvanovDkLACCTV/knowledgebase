# Как работает Render Tree в браузере

Чтобы нарисовать веб-страницу на экране, браузер выполняет несколько этапов. После получения ресурсов (HTML, CSS, JS и др.) и парсинга HTML в DOM и CSS в CSSOM, браузер приступает к **рендерингу**. Одним из ключевых этапов рендеринга является построение **Render Tree** (или дерево рендеринга).

![[Pasted image 20250523091253.png]]

## Что такое Render Tree?

**Render Tree** — это **визуальная репрезентация** документа. Это объединенное дерево на основе [[DOM]] (Document Object Model) и [[CSSOM]] (CSS Object Model). Оно используется браузером для расчета положения и размеров каждого видимого элемента.

В движке WebKit используется термин **Render Tree**, тогда как в других движках, например, Gecko, может использоваться термин Frame Tree.

---

## Построение Render Tree

Построение Render Tree запускается после того, как браузер составил DOM и CSSOM. Конструирование этого дерева начинается с прохода всего DOM-дерева от корня, с выявлением каждого видимого узла. Для каждой ноды (узла) в DOM находится подходящая запись в CSSOM. В итоге браузер создает видимые узлы с содержимым и их вычисленными стилями. Стили определяются путем применения всех подходящих правил с использованием CSS каскада.

Nodes в Render Tree называются **Renderer** (или Render Object и Render Node, в зависимости от браузера и спецификации).

CSS является **рендер-блокирующим ресурсом**, так как без построения CSSOM браузер не начнет третий этап — компоновку Render tree. Ожидание получения CSS не блокирует парсинг HTML, но он блокирует JavaScript, потому что JavaScript часто используется для выборки узлов документа по CSS-селекторам.

![[Pasted image 20250523092047.png]]

## Содержимое Render Tree

В Render tree **попадают только видимые элементы**.
*   Элементы, которые не должны быть показаны, например, `<head>`, а также их дети, или любые элементы с CSS свойством `display: none`, не будут включены в дерево рендера, так как они не должны быть отрисованы.
*   Узлы с правилом `visibility: hidden` включены в дерево рендера, так как они всё равно занимают своё место на странице.
*   В Render tree также добавляются элементы, которых нет непосредственно в DOM, такие как псевдоэлементы `::after` и `::before`.

## Использование Render Tree

После того, как у браузера появилось дерево рендеринга (Render Tree), он начинает «расставлять» элементы на странице. Этот процесс называется **Layout** (Компоновка). На этом шаге вычисляется геометрия каждого узла, то есть ширина, высота, положение элементов. Layout начинается с обхода Render Tree и является рекурсивным процессом, начинающимся от корневого узла, размеры которого равны размеру вьюпорта. Каждый Renderer имеет свой layout-метод и вызывает метод layout своих дочерних элементов.

После Layout следует этап **Paint** (Отрисовка). Во время отрисовки браузер наполняет пиксели на экране нужными цветами, конвертирует каждый контейнер box (сформированный на этапе Layout) в настоящие пиксели, рисует визуальные частицы элемента (текст, цвета, границы, тени) и заменяемые элементы (картинки, кнопки). Браузеру все еще недостаточно иметь DOM, стили, расположение элементов и их размеры (из Render Tree и Layout) для отрисовки; на этапе Paint создаются Paint Records, чтобы определить порядок рисования элементов и другие детали.

Процесс отрисовки является циклическим. Браузер перерисовывает экран каждый раз, когда на странице происходят какие-то изменения. Если, например, в DOM-дереве добавился новый узел, или изменился текст, то браузер построит **новое дерево рендеринга** и запустит вычисление позиции (Layout) и отрисовку (Paint) заново. Перерасчёт размеров и положения элементов (Reflow) запускает перерисовку (Repaint).

Таким образом, Render Tree является центральным представлением, объединяющим структуру DOM и стили CSSOM, необходимым для последующих этапов вычисления расположения и отрисовки элементов на веб-странице.


---

# Построение DOM и CSSOM в браузере

Чтобы отобразить веб-страницу, браузер выполняет несколько ключевых этапов. После получения исходных ресурсов (HTML, CSS, JS), браузер приступает к **парсингу** (parsing). Парсинг — это процесс "чтения" кода и преобразования его в абстракции, с которыми браузер может работать. Во время парсинга HTML и CSS строятся две основные модели: DOM и CSSOM.

![[Pasted image 20250523094002.png]]

## Построение DOM (Document Object Model)

*   **Что это:** DOM — это **абстрактное представление HTML-документа**. Браузер работает с DOM, а не напрямую с текстом разметки. С помощью DOM можно получать доступ к элементам, изменять структуру и оформление.
*   **Структура:** DOM представляет собой **дерево**. Корнем дерева является элемент `<html>`, остальные элементы — дочерние узлы. Чем больше узлов, тем сложнее построить дерево.
*   **Процесс парсинга HTML:**
    *   Парсинг начинается **инкрементально**, по мере скачивания HTML-страницы. Браузер сразу начинает обрабатывать первый кусочек данных.
    *   Включает **токенизацию** (разбиение кода на лексемы) и **построение дерева**. Парсер обрабатывает входящие токены (теги, атрибуты) и строит дерево документа.
    *   Может занимать **весь поток процесса** и является узким местом в производительности.

*   **Обработка внешних ресурсов во время парсинга HTML:**
    *   Парсер натыкается на ссылки на другие ресурсы (`<img>`, `<link>`, `<script>`).
    *   **Неблокирующие ресурсы** (например, изображения) браузер запрашивает параллельно с парсингом оставшейся части документа.
    *   **Блокирующие ресурсы** (например, скрипты без атрибутов `async` или `defer`) **приостанавливают обработку HTML** до своей полной загрузки. Это происходит, потому что JavaScript часто используется для выборки узлов документа, которые могут находиться дальше по разметке.
    *   Атрибут `defer` позволяет браузеру продолжать парсить страницу и выполнить скрипт позже.
    *   **Сканер предзагрузки** (Preload Scanner) обрабатывает содержимое документа и запрашивает высокоприоритетные ресурсы (CSS, JavaScript, шрифты) заранее, в фоновом режиме, уменьшая время блокирования рендера.

*   **Парсинг** начинается даже если ответ больше 14КБ (размер первого пакета данных).

![[Pasted image 20250523092158.png]]


---


## Построение CSSOM (CSS Object Model)

*   **Что это:** CSSOM — по аналогии с DOM, это **представление стилевых правил в виде дерева**. Браузер преобразует CSS файлы в карту стилей, с которой он может работать.
*   **Структура:** CSSOM также является **деревом**. Дерево узлов создается на основе CSS селекторов.
*   **Процесс парсинга CSS:**
    *   Когда браузер находит элемент `<link>` (или `<style>`), он скачивает и парсит CSS файл.
    *   Браузер считывает каждый набор правил и строит дерево.
    *   CSSOM дерево включает **стили пользовательского агента** (стили браузера по умолчанию).
    *   Браузер применяет правила **каскадно**, начиная с наиболее общих и переходя к более специфичным. Отсюда название Cascading Style Sheets.
*   **Блокирующий эффект:**
    *   Чтение стилей **приостанавливает чтение кода страницы**.
    *   **CSS является рендер-блокирующим ресурсом**, так как без построения CSSOM браузер не может начать следующий этап — построение Render Tree.
    *   Ожидание получения CSS не блокирует парсинг HTML (благодаря сканеру предзагрузки), но **блокирует выполнение JavaScript**, потому что JavaScript часто используется для выборки узлов документа по CSS-селекторам.
*   **Производительность:** Построение CSSOM происходит **очень быстро**. Оно часто включается в метрику "Повторное вычисление стилей" и, в целом, занимает меньше времени, чем, например, DNS запрос. С точки зрения оптимизации производительности здесь мало что можно сделать.

![[Pasted image 20250523093251.png]]

В итоге, браузер строит две независимые структуры: **DOM для структуры** и **CSSOM для стилей**. Эти две структуры затем объединяются для построения **Render Tree**, которое используется на последующих этапах рендеринга (Layout, Paint, Compositing).

![[Pasted image 20250523091946.png]]
#### Ccылки на источники

[Habr](https://habr.com/ru/articles/834184/)
[Mozilla Dev](https://developer.mozilla.org/ru/docs/Web/Performance/Guides/How_browsers_work)
[Doka](https://doka.guide/tools/how-the-browser-creates-pages/)
